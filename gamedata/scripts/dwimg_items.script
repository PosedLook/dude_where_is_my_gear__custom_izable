local keep_items = nil

ignore_items = nil
no_sec_dwg = {}
no_sec = {}

-- ==============================================================
-- ITEM PUNISH UTILS
-- ==============================================================

-- --------------------------------------------------------------
-- GET ITEM RELATED VALUES
-- --------------------------------------------------------------

local function scaled_chances(chances, item, section)
	if chances[3] == true or dwimg_main.config.enable_scale == false then
		return chances
	else
		local actor_rank = db.actor:character_rank()

		--[[
					( effective_rank - dwimg_main.config.rank_scale_from       ) ^dwimg_main.config.scaling_exponent
			mult  = ( -------------------------------------- )					
					( dwimg_main.config.rank_scale_until - dwimg_main.config.rank_scale_from     )
		]]

		local effective_rank = clamp(actor_rank, dwimg_main.config.rank_scale_from, dwimg_main.config.rank_scale_until)
		local rank_mult = math.pow((effective_rank - dwimg_main.config.rank_scale_from) / (dwimg_main.config.rank_scale_until - dwimg_main.config.rank_scale_from), dwimg_main.config.scaling_exponent)
		--dwimg_utils.print_dbg("Loss: Pow^" .. dwimg_main.config.scaling_exponent .. ": actor_rank: " .. actor_rank .. " from: " .. dwimg_main.config.rank_scale_from .. " until: " .. dwimg_main.config.rank_scale_until .. " = " .. rank_mult)


		if chances[4] > chances[1] then
			chances[1] = chances[1] + (rank_mult * (chances[4] - chances[1]))
		end

		if not(section == "bolt" or section == "bolt_bullet") then 
			effective_rank = clamp(actor_rank, dwimg_main.config.rank_scale_from2, dwimg_main.config.rank_scale_until2)
			rank_mult = math.pow((effective_rank - dwimg_main.config.rank_scale_from2) / (dwimg_main.config.rank_scale_until2 - dwimg_main.config.rank_scale_from2), dwimg_main.config.scaling_exponent)
			--dwimg_utils.print_dbg("Drop: Pow^" .. dwimg_main.config.scaling_exponent .. ": actor_rank: " .. actor_rank .. " from: " .. dwimg_main.config.rank_scale_from2 .. " until: " .. dwimg_main.config.rank_scale_until2 .. " = " .. rank_mult)

			if chances[5] > chances[2] then
				chances[2] = chances[2] + (rank_mult * (chances[5] - chances[2]))
			end
		end

		return chances
	end
end

local function get_chances(item, section, item_id)
	local iType = dwimg_utils.get_item_type(item, "drop&loss chance")
	
	if iType == dwimg_lists.item_type.GUN then
		dwimg_utils.print_dbg("IsWeapon")
		dwimg_utils.print_dbg("guns_chance")
		return {dwimg_main.config.chance_of_losing_guns, dwimg_main.config.keep_guns_chance, false, dwimg_main.config.chance_of_losing_guns_scaled, dwimg_main.config.keep_guns_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.UPGRADED then
		dwimg_utils.print_dbg("IsInDevices")
		dwimg_utils.print_dbg("upgraded_chance")
		return {dwimg_main.config.chance_of_losing_devices, dwimg_main.config.keep_device_chance, false, dwimg_main.config.chance_of_losing_devices_scaled, dwimg_main.config.keep_device_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.TOOL then
		dwimg_utils.print_dbg("IsInTool_list")
		dwimg_utils.print_dbg("tools_chance")
		return {dwimg_main.config.chance_of_losing_devices, dwimg_main.config.keep_device_chance, false, dwimg_main.config.chance_of_losing_devices_scaled, dwimg_main.config.keep_device_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.KIT then
		dwimg_utils.print_dbg("IsInKits_list")
		dwimg_utils.print_dbg("kits_chance")
		return {dwimg_main.config.chance_of_losing_kits, dwimg_main.config.keep_kits_chance, false, dwimg_main.config.chance_of_losing_kits_scaled, dwimg_main.config.keep_kits_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.MEDICAL then
		dwimg_utils.print_dbg("IsMedicalKind")
		dwimg_utils.print_dbg("medics_chance")
		return {dwimg_main.config.chance_of_losing_medics, dwimg_main.config.keep_medics_chance, false, dwimg_main.config.chance_of_losing_medics_scaled, dwimg_main.config.keep_medics_chance_scaled }	

	elseif iType == dwimg_lists.item_type.ARMOR then
		dwimg_utils.print_dbg("IsOutfit")
		dwimg_utils.print_dbg("outfits_chance")
		return {dwimg_main.config.chance_of_losing_outfits, dwimg_main.config.keep_outfit_chance, false, dwimg_main.config.chance_of_losing_outfits_scaled, dwimg_main.config.keep_outfit_chance_scaled }	
		
	elseif iType == dwimg_lists.item_type.ARTEFACT_PERK or iType == dwimg_lists.item_type.ARTEFACT_STAT or iType == dwimg_lists.item_type.PELT then
		dwimg_utils.print_dbg("IsArtefact not i_attach")
		dwimg_utils.print_dbg("artefact_chance")
		return {dwimg_main.config.chance_of_losing_artefacts, dwimg_main.config.keep_artefact_chance, false, dwimg_main.config.chance_of_losing_artefacts_scaled, dwimg_main.config.keep_artefact_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.ATTACHEMENT_WPN then
		dwimg_utils.print_dbg("IsWpnAttachment")
		dwimg_utils.print_dbg("gun_attachment_chance")
		return {dwimg_main.config.chance_of_losing_gun_attachments, dwimg_main.config.keep_gun_attachment_chance, false, dwimg_main.config.chance_of_losing_gun_attachments_scaled, dwimg_main.config.keep_gun_attachment_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.EXPLOSIVE then
		dwimg_utils.print_dbg("IsExplosivesKind")
		dwimg_utils.print_dbg("explosives_chance")
		return {dwimg_main.config.chance_of_losing_explosives, dwimg_main.config.keep_explosives_chance, false, dwimg_main.config.chance_of_losing_explosives_scaled, dwimg_main.config.keep_explosives_chance_scaled }
		
	elseif iType == dwimg_lists.item_type.AMMO then
		dwimg_utils.print_dbg("IsAmmo")
		dwimg_utils.print_dbg("ammo_chance")	
		if string.match(item:section(), "^mag_") then
			local is_carried_mag = magazine_binder and magazine_binder.is_carried_mag
			local toggle_carried_mag = magazine_binder and magazine_binder.toggle_carried_mag
			local is_magazine = magazine_binder and magazine_binder.is_magazine
			if is_magazine(section) and is_carried_mag(item_id) then
				toggle_carried_mag(item_id)
			end		
		end	
		return {dwimg_main.config.chance_of_losing_ammo, dwimg_main.config.keep_ammo_chance, false, dwimg_main.config.chance_of_losing_ammo_scaled, dwimg_main.config.keep_ammo_chance_scaled }
	else
		dwimg_utils.print_dbg("misc_chance")
		if section == "bolt" or section == "bolt_bullet" then
			return {dwimg_main.config.chance_of_losing_items, 100, false, dwimg_main.config.chance_of_losing_items_scaled, dwimg_main.config.keep_misc_items_chance_scaled}	
		else
			return {dwimg_main.config.chance_of_losing_items, dwimg_main.config.keep_misc_items_chance, false, dwimg_main.config.chance_of_losing_items_scaled, dwimg_main.config.keep_misc_items_chance_scaled }
		end
	end
end

rule_a_prot = {}
rule_b_prot = {}
local function get_exemption(item, section)
	local sleep = dwimg_utils.get_sleep_state()	
	local i_type = dwimg_utils.get_item_type(item, "exemption")
	local rule_a = false
	local rule_b = false
	
	-- Separate conditions for rule_a
	local max_rank_exemption_a = dwimg_main.config.max_rank_exemption > db.actor:character_rank()
	local gained_rank_enabled_a = dwimg_main.config.gained_rank_exemption > 0
	local gained_rank_exemption_a = gained_rank_enabled_a and (db.actor:character_rank() - sleep.rank < dwimg_main.config.gained_rank_exemption)
	local passed_time_exemption_a = dwimg_main.config.passed_time_exemption > (dwimg_utils.get_game_seconds() - (sleep.time + dwimg_main.skipped_time))/3600
	local max_time_exemption_a = dwimg_main.config.max_time_exemption > (dwimg_utils.get_game_seconds() - dwimg_main.skipped_time)/3600
	
	rule_a = max_rank_exemption_a or gained_rank_exemption_a or passed_time_exemption_a or max_time_exemption_a
	
	-- Separate conditions for rule_b
	local max_rank_exemption_b = dwimg_main.config.max_rank_exemption2 > db.actor:character_rank()
	local gained_rank_enabled_b = dwimg_main.config.gained_rank_exemption2 > 0
	local gained_rank_exemption_b = gained_rank_enabled_b and (db.actor:character_rank() - sleep.rank < dwimg_main.config.gained_rank_exemption2)
	local passed_time_exemption_b = dwimg_main.config.passed_time_exemption2 > (dwimg_utils.get_game_seconds()-(dwimg_main.skipped_time+sleep.time))/3600
	local max_time_exemption_b = dwimg_main.config.max_time_exemption2 > (dwimg_utils.get_game_seconds()-dwimg_main.skipped_time)/3600
	
	rule_b = max_rank_exemption_b or gained_rank_exemption_b or passed_time_exemption_b or max_time_exemption_b
	
	-- Print true conditions if any exemption applies
	if rule_a or rule_b then
		local true_conditions = {}
		if rule_a then
			if max_rank_exemption_a then table.insert(true_conditions, "max_rank_exemption_a") end
			if gained_rank_exemption_a then table.insert(true_conditions, "gained_rank_exemption_a") end
			if passed_time_exemption_a then table.insert(true_conditions, "passed_time_exemption_a") end
			if max_time_exemption_a then table.insert(true_conditions, "max_time_exemption_a") end
		end
		if rule_b then
			if max_rank_exemption_b then table.insert(true_conditions, "max_rank_exemption_b") end
			if gained_rank_exemption_b then table.insert(true_conditions, "gained_rank_exemption_b") end
			if passed_time_exemption_b then table.insert(true_conditions, "passed_time_exemption_b") end
			if max_time_exemption_b then table.insert(true_conditions, "max_time_exemption_b") end
		end
		dwimg_utils.print_dbg("Exemption conditions met: " .. table.concat(true_conditions, ", "))
	end
	
	--dwimg_utils.print_dbg("Current time " .. tostring(dwimg_utils.get_game_seconds()/3600) .. " without skipped time " .. tostring(dwimg_main.skipped_time/3600) .. " is " .. tostring((dwimg_utils.get_game_seconds()-dwimg_main.skipped_time)/3600) )
	if (rule_a == false) and (rule_b == false) then
		return false
	end
	
	if (dwimg_main.config.exemption_everything == 1 and rule_a) or (dwimg_main.config.exemption_everything == 2 and rule_b) then
		return true
	end
	
	if (rule_a and rule_a_prot[i_type]) or (rule_b and rule_b_prot[i_type]) then
		return true
	else
		return false
	end
end

-- --------------------------------------------------------------
-- DETACH WEAPON ATTACHEMENTS
-- --------------------------------------------------------------

local function detach_scope_dwimg(weapon)
	local detach_infos = {
	["spw_wpn"] = nil,
	["spw_att"] = nil,
	}
	local parent_section = ini_sys:r_string_ex(weapon:section(),"parent_section")
	if (not parent_section or weapon:section() == parent_section) then 
		return nil
	end
	
	local old_weapon = alife_object(weapon:id())	
	
	-- Determine which addon is attached to the weapon.
	-- Create the item in the db.actor's inventory when found.
	for k, v in pairs(utils_data.collect_sections(ini_sys, {"addons_table"})) do
		if (string.find(weapon:section(), k)) then
			--give_object_to_db.actor(k)
			detach_infos["spw_att"] = alife_create_item(k, db.actor)
			break
		end
	end
	if detach_infos["spw_att"] == nil then
		return nil
	end
	-- Create objects for the 'before' and 'after' detachment weapons.
	local new_weapon = old_weapon and alife_clone_weapon(old_weapon, parent_section)
	detach_infos["spw_wpn"] = new_weapon
	return detach_infos
end

local function detach_suppressor_dwimg(weapon)	
	if weapon:weapon_silencer_status() == 2 then
		if weapon:weapon_is_silencer() then
			local supSection = utils_item.get_param(weapon:section(), weapon:id(), "silencer_name", "string")
			local sil_info = {id = weapon:id(), section = supSection}
			weapon:weapon_addon_detach(sil_info.section, true)
			return true
		end
	end
	return false
end

local function detach_gl_dwimg(weapon)
	if (ini_sys:r_float_ex(weapon:section(),"grenade_launcher_status") > 0) then
		if weapon:is_weapon_gl() then
			local supSection = utils_item.get_wpn_param(obj, weapon:section(), "grenade_launcher_name")
			local gl_info = {id = weapon:id(), section = supSection}
			weapon:weapon_addon_detach(gl_info.section, true)
			return true		
		end
	end
	return false
end

-- --------------------------------------------------------------
-- DISASSEMBLE
-- --------------------------------------------------------------

local function disassemble(section, spw_target)
	local ind = 1
	local ini = ini_file("items\\settings\\craft.ltx")
	local result, id, value = 0, 0, 0
	
	while ini:section_exist(tostring(ind)) and not(tostring(id) == section) do
		local n = ini:line_count(tostring(ind)) or 0 
		local i = 0
		while i <= n-1 and not(tostring(id) == section) do
			result, id, value = ini:r_line(tostring(ind) , i , "", "")
			id = string.sub(id,3)
			i = i + 1
		end
	ind = ind + 1
	end
	local t = str_explode(value,",")
	if dwimg_utils.check_all_lists("devices",t[3]) ~= nil then
		disassemble(t[3], spw_target)
	end
	for i = 5, #t - 1, 2 do
		for i2 = 1, t[i+1] do
			if( math.random(1,100) <= dwimg_main.config.keep_device_part_chance ) then
				local spw_prt = alife_create_item(t[i], spw_target)
				no_sec[spw_prt.id] = true
			end
		end
	end

end

local function main_disassemble(item, drop, obj, item_id, section)
	if (IsWeapon(item) and not(ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) and math.random(1,100) <= dwimg_main.config.broken_gun_chance) or ((IsOutfit(item) or IsHeadgear(item)) and math.random(1,100) <= dwimg_main.config.broken_armor_chance) or (dwimg_utils.check_all_lists("devices",section) ~= nil and math.random(1,100) <= dwimg_main.config.broken_device_chance)  then
		local spw_target = db.actor
		if drop then
			spw_target = obj
		end
		if IsWeapon(item) or IsOutfit(item) or IsHeadgear(item) then

			local spw_prt
			local parts = item_parts.get_parts_con(item)
			if parts then
				for k,v in pairs(parts) do
					if math.random(1,100) <= dwimg_main.config.keep_gun_armor_parts_chance and (k ~= section) then
						spw_prt = alife_create_item(k, spw_target)
						if spw_prt then
							no_sec[tostring(spw_prt.id)] = true
							CreateTimeEvent("Wait_for_spawn", spw_prt.id, 0, function(id, con)
								if level.object_by_id(id) then
									--dwimg_utils.print_dbg("Condition: " .. con)
									level.object_by_id(id):set_condition(con/100)
									return true
								else
									return false
								end
							end, spw_prt.id, parts[k])
						else
							dwimg_utils.issue("No spw_prt spawned for "  .. section)
						end
					end
				end
			else
				dwimg_utils.issue("Couldn't find parts of item during main disassemble")
			end
			
			local installed_upgrades = utils_item.get_upgrades_installed(item)
			local upgr_tools = {}
			for i=1,#installed_upgrades do
				local tool = utils_item.get_upgrade_sect_tool(section, installed_upgrades[i])
				table.insert(upgr_tools,tool)
			end
			for i=1,#upgr_tools do
				if math.random(1,100) <= dwimg_main.config.keep_upgrade_chance then
					spw_prt = alife_create_item(upgr_tools[i], spw_target)
					no_sec[tostring(spw_prt.id)] = true
				end
			end							
		else
			disassemble(section, spw_target)
		end
		return true
	else
		return false
	end
end

-- ==============================================================
-- ITERATE INVENTORY
-- ==============================================================

function itr_inv(temp, item)
	dwimg_utils.print_dbg("item: " .. item:section() .. " [" .. ini_sys:r_string_ex(item:section(), "kind") .. "] " .. " [" .. item:id() .. "]")
	local section = item:section()
	local item_id = item:id()
	dwimg_main.time_item_calc = time_global()
	--if ini_sys:r_float_ex(section,"cost") ~= nil and ini_sys:r_float_ex(section,"cost") ~= 0 then 
	--	dwimg_utils.print_dbg("Cost of " .. item_id .. " is " .. ini_sys:r_float_ex(section,"cost"))
	--end

	if ini_sys:r_bool_ex(section, "quest_item", false) then
		dwimg_utils.print_dbg("Stopped for quest_item: " .. item_id)
		return
	end

	if no_sec[tostring(item_id)] then
		dwimg_utils.print_dbg("Stopped for no spawn hook: " .. item_id)
		return
	end

	if dwimg_utils.get_item_type(item, "Quest item stop itr_inv") == dwimg_lists.item_type.QUEST then
		dwimg_utils.print_dbg("Stopped for QuestKind: " .. item_id)
		return
	end
	
	if item_id == b_id then
		dwimg_utils.print_dbg("Stopped for b_id: " .. item_id)
		return
	end

	if ignore_items[section] then
		dwimg_utils.print_dbg("Stopped for ignore: " .. item_id)
	   return
	end
	
	if keep_items[section] ~= nil and not(dwimg_utils.check_all_lists("anti_keepers",section)) then
		dwimg_utils.print_dbg("Stopped for keep_items: " .. item_id)
		return
	end

	if dwimg_utils.get_item_type(item, nil) == dwimg_lists.item_type.GUN then
		if magazines and magazine_binder and magazines.eject_magazine and magazine_binder.is_supported_weapon and magazine_binder.is_supported_weapon(item) then
			magazines.eject_magazine(item)
		else
			item:force_unload_magazine(true)
		end
	end

	--remove scope, silencer and gl
	if dwimg_utils.get_item_type(item, nil) == dwimg_lists.item_type.GUN then					
		detach_suppressor_dwimg(item)
		detach_gl_dwimg(item)
		if detach_scope_dwimg(item) ~= nil then
			dwimg_utils.print_dbg("Cancelled for scope: " .. item_id)
			return
		end
	end

	--remove psu and convert overflow power to exo batteries_exo
	if IsOutfit(item) and item_exo_device.is_exo(item) and item_exo_device.check_remove_psu(item) == "st_remove_psu" then
		local power_overflow = 0
		if item_exo_device.get_data(item_id).power > 100 then
			power_overflow = item_exo_device.get_data(item_id).power - 100
		end
		while power_overflow > 0 do 
			local new_bat = alife_create_item("batteries_exo", db.actor)
			no_sec[tostring(new_bat.id)] = true
			CreateTimeEvent("Wait_for_spawn", new_bat.id, 0, function(id, charge)
			dwimg_utils.print_dbg("Wait for " .. id)
			if level.object_by_id(id) then
				level.object_by_id(id):set_condition(charge/100)
				return true
			else
				return false
			end
			end, new_bat.id, dwimg_utils.clamp(power_overflow, 0, 100))
			power_overflow = power_overflow - dwimg_utils.clamp(power_overflow, 0, 100)
		end
		item_exo_device.remove_psu(item)
	end
	
	if get_exemption(item, section) then
		dwimg_utils.print_dbg("Exemption: " .. item_id)						
		return
	end
	
	--condition_loss
	if (dwimg_main.config.max_condition_lose > 0) then
		if IsWeapon(item) and not (ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) and (item_backpack.is_in_slot(item) or dwimg_main.config.condition_unequipped) then
			local parts = item_parts.get_parts_con(item)
			if parts then
					local count = 0
					for k, v in pairs(parts) do
						count = count + 1
					end
					local sum = 0
					for k, v in pairs(parts) do
						local condition_reduction =
							(math.random(dwimg_main.config.min_condition_lose, dwimg_main.config.max_condition_lose))
						if (dwimg_main.config.min_weapon_condition < parts[k]) then
							if dwimg_main.config.spread_weapon_condition then
								if math.random(1,2) == 1 then
									parts[k] = math.floor(parts[k] - (condition_reduction / count))
								else
									parts[k] = math.ceil(parts[k] - (condition_reduction / count))
								end
							else
								parts[k] = parts[k] - condition_reduction
							end
							if (parts[k] < dwimg_main.config.min_weapon_condition) then
								parts[k] = dwimg_main.config.min_weapon_condition
							end
						end
						sum = sum + parts[k]
					end
					item_parts.set_parts_con(item_id, parts)
			end
		elseif (IsOutfit(item) or IsHeadgear(item)) and (item_backpack.is_in_slot(item) or dwimg_main.config.condition_unequipped) then
				local condition = item:condition()
				local condition_reduction =
					(math.random(dwimg_main.config.min_condition_lose, dwimg_main.config.max_condition_lose)) / 100
				if ((dwimg_main.config.min_armor_condition / 100) < condition ) then
					condition = condition - condition_reduction
					if ((dwimg_main.config.min_armor_condition / 100) > condition) then
						condition = dwimg_main.config.min_armor_condition / 100
					end
				end
				item:set_condition(condition)
		end
	end

	--part break
	if ((IsWeapon(item) and not (ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) or IsOutfit(item) or IsHeadgear(item)) and (item_backpack.is_in_slot(item) or dwimg_main.config.condition_unequipped)) and dwimg_main.config.part_break_chance > 0 then
		local sum, cnt = 0,0
		local parts = item_parts.get_parts_con(item)
		for k, v in pairs(parts) do
			if k ~= section then
				if dwimg_main.config.part_break_chance >= math.random(1,100) then
					parts[k] = 1
				end
				sum = sum + parts[k]
				dwimg_utils.print_dbg("summed " .. parts[k] .. " - " .. tostring(k))
				cnt = cnt + 1
			end
		end
		if IsOutfit(item) or IsHeadgear(item) then
			item:set_condition(dwimg_utils.clamp(math.ceil(sum/cnt),1,100)/100)
		end
		parts[section] = sum/cnt
		item_parts.set_parts_con(item_id, parts)
		
	end
	
	--remove upgrades
	if not(no_sec_dwg[tostring(item_id)]) and ((IsWeapon(item) and not(ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) or IsOutfit(item) or IsHeadgear(item) or section == "wpn_binoc_inv")) and dwimg_main.config.remove_upgrade_chance > 0  then
		local found_upgrades = dwimg_utils.shuffle_table(utils_item.get_upgrades_installed(item, item_id, false))
		local to_keep = dwimg_utils.binomial_sample(#found_upgrades, 100-dwimg_main.config.remove_upgrade_chance)
		if #found_upgrades > 0 and not(to_keep == #found_upgrades ) then 	
			local clo_itm = alife_create_item(section, db.actor)
			no_sec_dwg[tostring(clo_itm.id)] = true
			item_parts.set_parts_con(clo_itm.id, item_parts.get_parts_con(item))
			local ammo 
			if IsWeapon(item) then
				ammo = item:get_ammo_in_magazine()
				item:unload_magazine(false)
			end
			alife_release(item)
			dwimg_utils.print_dbg("Wait for " .. clo_itm.id)
			CreateTimeEvent("Wait_for_spawn", clo_itm.id, 0, function(id, to_keep, found_upgrades)
				if level.object_by_id(id) then
					if IsWeapon(level.object_by_id(id)) then	
						level.object_by_id(id):unload_magazine(false)
					end
					local skip_upgr = {}
					local i = 1
					while to_keep > 0 do
						while skip_upgr[i] do
							i = i + 1
						end
						local rnd_upgr = found_upgrades[i]
						if not rnd_upgr then
							return true
						end
						dwimg_utils.print_dbg("try upgrade: " .. rnd_upgr .. " for " .. id .. " with " .. to_keep .. " missing")
						if not utils_item.has_this_upgrade(level.object_by_id(id), section, rnd_upgr) then
							inventory_upgrades.force_upgrade = true
							level.object_by_id(id):install_upgrade(rnd_upgr)
							if utils_item.has_this_upgrade(level.object_by_id(id), section, rnd_upgr) then
								to_keep = to_keep - 1
								skip_upgr[i] = true
								i=0
							end
						end
						i = i+1
					end
					
					if IsWeapon(level.object_by_id(id)) then
						level.object_by_id(id):set_ammo_elapsed(ammo)
					end
					return true
				else
					return false
				end
			end, clo_itm.id, to_keep, found_upgrades)
			dwimg_utils.print_dbg("Cancelled for upgrades: " .. item_id)
			return
		end
	end
	
	--downgrade
	if not(no_sec_dwg[tostring(item_id)]) and dwimg_utils.check_all_lists("devices",section) ~= nil and math.random(1, 100) <= dwimg_main.config.downgrade_chance then
		dwimg_utils.print_dbg("Downgrade: " .. section .. " to " .. dwimg_utils.check_all_lists("devices",section))
		alife_release(item)
		local spw_itm = alife_create_item(dwimg_utils.check_all_lists("devices",section), db.actor)
		no_sec_dwg[tostring(spw_itm.id)] = true
		dwimg_utils.print_dbg("Cancelled: " .. item_id)
		return
	end

	--[[ Here is how to get money value of item if ever needed
		ini_sys:r_float_ex(section,"cost")
	]]

	--other condition loss
	if (dwimg_main.config.max_condition_lose2 > 0) then
		if (IsMelee(item) and dwimg_main.config.condition_melee) or (dwimg_utils.get_item_type(item, "condition loss 2") == dwimg_lists.item_type.ARTEFACT_PERK and dwimg_main.config.condition_perk_artefact) or (dwimg_utils.get_item_type(item, "condition loss 2") == dwimg_lists.item_type.ARTEFACT_STAT and dwimg_main.config.condition_stat_artefact) or (dwimg_utils.get_item_type(item, "condition loss 2") == dwimg_lists.item_type.PELT and dwimg_main.config.condition_pelt) then
			item:set_condition(dwimg_utils.clamp(item:condition()-math.random(dwimg_main.config.min_condition_lose2, dwimg_main.config.max_condition_lose2)/100,0.01,1))
		end
	end

	local chances = scaled_chances(get_chances(item, section, item_id), item, section)
	
	local loss_roll = math.random(1, 100)
	local loss_chance = chances[1]
	local lose = loss_roll <= loss_chance

	local drop_roll = math.random(1, 100)
	local drop_chance = chances[2]
	local drop = drop_roll <= drop_chance

	dwimg_utils.print_dbg("    #Fate said for " .. item_id .. " | lose = " .. tostring(lose) ..  " (" .. loss_roll .. "/" .. loss_chance .. ") | drop = " ..  tostring(drop) .. " (" .. drop_roll .. "/" .. drop_chance .. ")")
	--disassemble
	if not(lose) then
		if main_disassemble(item, drop, dwimg_main.r_obj, item_id, section) then
			alife_release(item)	
			dwimg_utils.print_dbg("Cancelled for disassemble " .. item_id)
			return
		end
	end

	--drop loss keep
	if lose then
		-- I've noticed that for some reason bolts cannot be alife_released properly,
		-- it always results in a stacktrace. This is a bandaid to prevent that.
		if not IsBolt(item) then
			alife_release(item)
			dwimg_main.add_to_dropped_item_list(item, 'l', dwimg_main.dropped_stash.id)
		else
			dwimg_utils.print_dbg("Ignoring bolt loss " .. item_id)
		end
	elseif drop and not(dwimg_utils.check_all_lists("ignored_levels", level.name())) then
		db.actor:transfer_item(item, dwimg_main.r_obj)
		dwimg_main.add_to_dropped_item_list(item, 'd', dwimg_main.dropped_stash.id)
	else
		return
	end
			
end

-- ==============================================================
-- SCRIPT CALLBACKS
-- ==============================================================

-- --------------------------------------------------------------
-- HOOK ITEMS SPAWNED
-- --------------------------------------------------------------

local function actor_on_item_take(item)
	local sleep = dwimg_utils.get_sleep_state()
	if item and dwimg_main.death_init then
		dwimg_utils.print_dbg("item spawn hook# " .. "item: " .. item:section() .. " [" .. ini_sys:r_string_ex(item:section(), "kind") .. "] " .. " [" .. item:id() .. "]")
		dwimg_main.time_item_calc = time_global()
		itr_inv(nil, item)
	end
end

-- --------------------------------------------------------------
-- STASH ITEM LOSS OVER TIME
-- --------------------------------------------------------------

local tracked_stashes = {}
local function actor_on_update()
	local curr_time = game.get_game_time()
	if (previous_time == nil) then previous_time = curr_time end
	if not (curr_time:diffSec(previous_time) > 5) then
		return
	end
	previous_time = curr_time
	local sleep = dwimg_utils.get_sleep_state()
	local no_trackers = true
	for stash_id, v  in pairs(tracked_stashes) do
		no_trackers = false
		local se_obj, obj = alife_object(stash_id), get_object_by_id(stash_id)
		local curr_game_time = dwimg_utils.get_game_seconds()
		if se_obj then
			local time_passed = math.floor((curr_game_time - sleep.dropped_stashes[stash_id]["loss_time"])/3600) - dwimg_main.config.stash_loss_start
			if obj and time_passed  > 1 then
				dwimg_utils.print_dbg("Time passed " .. time_passed)
				local keep_chance = (1 - (dwimg_main.config.stash_loss_chance / 100))^(time_passed)
				dwimg_utils.print_dbg("obj and chance is " .. keep_chance)
				local empty_stash = true
				obj:iterate_inventory_box( function(owner,itm)
					local tmp_keep_chance = dwimg_main.config.consider_loss_chance and 1-(((1-keep_chance) * (scaled_chances(get_chances(itm, itm:section(), itm:id()), itm, itm:section())[1])/100)) or keep_chance
					
					if tmp_keep_chance*100 >= math.random(1,100) then
						empty_stash = false
						dwimg_utils.print_dbg("Kept " .. itm:section() .. " with chance " .. tmp_keep_chance)
					else
						dwimg_utils.print_dbg("Lost " .. itm:section() .. " with chance " .. tmp_keep_chance)
						alife_release(itm)
					end	
				end)
				if empty_stash == true  then	
					sleep.dropped_stashes[stash_id] = nil
					level.map_remove_object_spot(obj, "treasure")
					alife_release(obj)
					dwimg_utils.print_dbg("Emptied stash detected and deleted!")
				else
					sleep.dropped_stashes[stash_id]["loss_time"] = sleep.dropped_stashes[stash_id]["loss_time"] + time_passed * 3600
				end
			end
		else
			dwimg_utils.print_dbg("Untracking no se_obj")
			tracked_stashes[stash_id] = nil
		end
	end
	if no_trackers == true then
		dwimg_utils.print_dbg("No more tracking")
		UnregisterScriptCallback("actor_on_update", actor_on_update)	
	end
end

function settings_loaded()
	if dwimg_main.config.stash_loss_chance > 0 then
		UnregisterScriptCallback("actor_on_update", actor_on_update)
		tracked_stashes = {}
		local sleep = dwimg_utils.get_sleep_state()
		for k, v in pairs(sleep.dropped_stashes) do
			dwimg_utils.print_dbg("Added stash tracking for " .. tostring(k))
			tracked_stashes[k] = true
		end
		RegisterScriptCallback("actor_on_update", actor_on_update)
	else
		UnregisterScriptCallback("actor_on_update", actor_on_update)
	end
end

-- --------------------------------------------------------------
-- INIT SCRIPTCALLBACKS
-- --------------------------------------------------------------

function on_game_start()
	RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
    local ini_stash = ini_file("items\\settings\\backpack_stash.ltx")
    keep_items = utils_data.collect_section(ini_stash, "actor_backpack_keep_items", true)
end

