--[[
Dude where's my gear!? is inspired by EFT, where you lose all your gear when you die.
The idea is to put together a hideout with some extra weapons and gear,
still you'll have the opportunity of getting some of your gear back if you return (and survive) to the place where you died.
You'll lose a % of money and also equipped items will lose condition when you drop them.
--]] 

-- Configuration table to avoid 200 local variable limit
config = {}
local death_init = false
local dropped_stash
local do_item_dropping -- disable item dropping if in underground labs
local r_obj
local currently_respawning = nil
local last_death_time = 0
local respawn_done = false
local global_healing = 1
local global_satiety = 1
local global_thirst = -10000
local options_vol = 1
local skipped_time = 0
local time_item_calc = nil
local actor_last_health = 1

local ignore_items = nil

local rule_a_prot = {}
local rule_b_prot = {}
local function init_protections()
	rule_a_prot = {}
	rule_b_prot = {}
	if config.exemption_guns == 1 then
		rule_a_prot[dwimg_lists.item_type.GUN] = true
	elseif config.exemption_guns == 2 then
		rule_b_prot[dwimg_lists.item_type.GUN] = true
	end
	if exemption_gun_attachements == 1 then
		rule_a_prot[dwimg_lists.item_type.ATTACHEMENT_WPN] = true
	elseif exemption_gun_attachements == 2 then
		rule_b_prot[dwimg_lists.item_type.ATTACHEMENT_WPN] = true
	end
	if config.exemption_outfits == 1 then
		rule_a_prot[dwimg_lists.item_type.ARMOR] = true
	elseif config.exemption_outfits == 2 then
		rule_b_prot[dwimg_lists.item_type.ARMOR] = true
	end
	if exemption_artefacts == 1 then
		rule_a_prot[dwimg_lists.item_type.ARTEFACT_PERK] = true
		rule_a_prot[dwimg_lists.item_type.ARTEFACT_STAT] = true
		rule_a_prot[dwimg_lists.item_type.PELT] = true
	elseif exemption_artefacts == 2 then
		rule_a_prot[dwimg_lists.item_type.ARTEFACT_PERK] = true
		rule_a_prot[dwimg_lists.item_type.ARTEFACT_STAT] = true
		rule_a_prot[dwimg_lists.item_type.PELT] = true
	end
	if exemption_device == 1 then
		rule_a_prot[dwimg_lists.item_type.UPGRADED] = true
	elseif exemption_device == 2 then
		rule_b_prot[dwimg_lists.item_type.UPGRADED] = true
	end
	if exemption_kit == 1 then
		rule_a_prot[dwimg_lists.item_type.KIT] = true
	elseif exemption_kit == 2 then
		rule_b_prot[dwimg_lists.item_type.KIT] = true
	end
	if exemption_tools == 1 then
		rule_a_prot[dwimg_lists.item_type.TOOL] = true
	elseif exemption_tools == 2 then
		rule_b_prot[dwimg_lists.item_type.TOOL] = true
	end
	if exemption_explosives == 1 then
		rule_a_prot[dwimg_lists.item_type.EXPLOSIVE] = true
	elseif exemption_explosives == 2 then
		rule_b_prot[dwimg_lists.item_type.EXPLOSIVE] = true
	end
	if config.exemption_ammo == 1 then
		rule_a_prot[dwimg_lists.item_type.AMMO] = true
	elseif config.exemption_ammo == 2 then
		rule_b_prot[dwimg_lists.item_type.AMMO] = true
	end
	if config.exemption_medics == 1 then
		rule_a_prot[dwimg_lists.item_type.MEDICAL] = true
	elseif config.exemption_medics == 2 then
		rule_b_prot[dwimg_lists.item_type.MEDICAL] = true
	end
	if config.exemption_misc == 1 then
		rule_a_prot[dwimg_lists.item_type.MISC] = true
	elseif config.exemption_misc == 2 then
		rule_b_prot[dwimg_lists.item_type.MISC] = true
	end
end

local function add_to_dropped_item_list(item, status, stash_id)
    local sleep = dwimg_utils.get_sleep_state()
    local item_name = ui_item.get_sec_name(item:section()) or 'unknown'
    local drop_stash = sleep.dropped_stashes[stash_id]
    if status == "d" then
        dwimg_utils.print_dbg("Dropped item: " .. item_name)
        if drop_stash.last_dropped_item_list[item_name] == nil then
            drop_stash.last_dropped_item_list[item_name] = 1
        else
            drop_stash.last_dropped_item_list[item_name] = drop_stash.last_dropped_item_list[item_name] + 1
        end
    elseif status == "l" then
        dwimg_utils.print_dbg("Lost item: " .. item_name)
        if drop_stash.last_lost_item_list[item_name] == nil then
            drop_stash.last_lost_item_list[item_name] = 1
        else
            drop_stash.last_lost_item_list[item_name] = drop_stash.last_lost_item_list[item_name] + 1
        end
    end
end

local function create_report_msg_string(list_lost_only, stash_id)
    list_lost_only = list_lost_only or false
    local sleep = dwimg_utils.get_sleep_state()
    local stash_items = sleep.dropped_stashes[stash_id] or nil
    local msg = ""
    if not list_lost_only and stash_items then
        for item_name, count in pairs(stash_items.last_dropped_item_list) do
            msg = msg .. "- " .. item_name .. " x" .. count .. " \\n"
            -- dwimg_utils.print_dbg("Dropped item: " .. item_name .. " x" .. count)
        end
    end
    if stash_items then
        for item_name, count in pairs(stash_items.last_lost_item_list) do
            msg = msg .. "- " .. item_name .. " x" .. count .. " \\n"
            -- dwimg_utils.print_dbg("Lost item: " .. item_name .. " x" .. count)
        end
    end
    return msg
end

local function send_items_report_news_msg(list_lost, stash_id)
    local items_recount = create_report_msg_string(list_lost, stash_id)
    local msg = list_lost and "You lost or got stolen:" or
                    "You woke up and did a quick item recount, looks like this is missing:"
    db.actor:give_game_news("Item recount", tostring(msg .. " \\n" .. items_recount), "ui_inGame2_neutral_2_mask", 0,
        20000)
end

function detach_scope_dwimg(weapon)
	local detach_infos = {
	["spw_wpn"] = nil,
	["spw_att"] = nil,
	}
	local parent_section = ini_sys:r_string_ex(weapon:section(),"parent_section")
	if (not parent_section or weapon:section() == parent_section) then 
		return nil
	end
	
	local old_weapon = alife_object(weapon:id())	
	
	-- Determine which addon is attached to the weapon.
	-- Create the item in the db.actor's inventory when found.
	for k, v in pairs(utils_data.collect_sections(ini_sys, {"addons_table"})) do
		if (string.find(weapon:section(), k)) then
			--give_object_to_db.actor(k)
			detach_infos["spw_att"] = alife_create_item(k, db.actor)
			break
		end
	end
	if detach_infos["spw_att"] == nil then
		return nil
	end
	-- Create objects for the 'before' and 'after' detachment weapons.
	local new_weapon = old_weapon and alife_clone_weapon(old_weapon, parent_section)
	detach_infos["spw_wpn"] = new_weapon
	return detach_infos
end

function detach_suppressor_dwimg(weapon)	
	if weapon:weapon_silencer_status() == 2 then
		if weapon:weapon_is_silencer() then
			local supSection = utils_item.get_param(weapon:section(), weapon:id(), "silencer_name", "string")
			local sil_info = {id = weapon:id(), section = supSection}
			weapon:weapon_addon_detach(sil_info.section, true)
			--dwimg_utils.print_dbg("Detached suppressor")
			return true
		end
	end
	return false
end

function detach_gl_dwimg(weapon)
	if (ini_sys:r_float_ex(weapon:section(),"grenade_launcher_status") > 0) then
		if weapon:is_weapon_gl() then
			local supSection = utils_item.get_wpn_param(obj, weapon:section(), "grenade_launcher_name")
			local gl_info = {id = weapon:id(), section = supSection}
			weapon:weapon_addon_detach(gl_info.section, true)
			--dwimg_utils.print_dbg("Detached gl")
			return true		
		end
	end
	return false
end

local function load_settings_money()
	config.min_money_percentage = dwimg_mcm.get_config("money/min_money_percentage")
	config.max_money_percentage = dwimg_mcm.get_config("money/max_money_percentage")
	config.min_money_to_drop_percentage = dwimg_mcm.get_config("money/min_money_to_drop_percentage")
	config.max_money_to_drop_percentage = dwimg_mcm.get_config("money/max_money_to_drop_percentage")
	config.min_money_to_keep_inventory = dwimg_mcm.get_config("money/min_money_to_keep_inventory")
	config.min_money_to_keep_general = dwimg_mcm.get_config("money/min_money_to_keep_general")	
	config.max_lost_money = dwimg_mcm.get_config("money/max_lost_money")
	config.money_y_rank = dwimg_mcm.get_config("money/money_y_rank")
	
	if config.max_money_percentage < config.min_money_percentage then
		config.max_money_percentage = config.min_money_percentage
	end
	if config.max_money_to_drop_percentage < config.min_money_to_drop_percentage then
		config.max_money_to_drop_percentage = config.min_money_to_drop_percentage
	end
	if config.min_money_to_keep_general < config.min_money_to_keep_inventory then
		config.min_money_to_keep_general = config.min_money_to_keep_inventory
	end
end
local function load_settings_condition()
	--condition_ga
    config.min_condition_lose = dwimg_mcm.get_config("condition/condition_ga/min_condition_lose")
    config.max_condition_lose = dwimg_mcm.get_config("condition/condition_ga/max_condition_lose")
	config.part_break_chance = dwimg_mcm.get_config("condition/condition_ga/part_break_chance")
	config.min_weapon_condition = dwimg_mcm.get_config("condition/condition_ga/min_weapon_condition")
	config.min_armor_condition = dwimg_mcm.get_config("condition/condition_ga/min_armor_condition")
	config.condition_unequipped = dwimg_mcm.get_config("condition/condition_ga/condition_unequipped")
	config.spread_weapon_condition = dwimg_mcm.get_config("condition/condition_ga/spread_weapon_condition")
	--condition_o
    config.min_condition_lose2 = dwimg_mcm.get_config("condition/condition_o/min_condition_lose2")
    config.max_condition_lose2 = dwimg_mcm.get_config("condition/condition_o/max_condition_lose2")
    config.condition_melee = dwimg_mcm.get_config("condition/condition_o/condition_melee")	
	config.condition_perk_artefact = dwimg_mcm.get_config("condition/condition_o/condition_perk_artefact")
	config.condition_stat_artefact = dwimg_mcm.get_config("condition/condition_o/condition_stat_artefact")
	config.condition_pelt = dwimg_mcm.get_config("condition/condition_o/condition_pelt")

	if config.max_condition_lose < config.min_condition_lose then
		config.max_condition_lose = config.min_condition_lose
	end
	if config.max_condition_lose2 < config.min_condition_lose2 then
		config.max_condition_lose2 = config.min_condition_lose2
	end		
end
local function load_settings_item_loss()
	--lose_keep
	config.chance_of_losing_guns = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_guns")
	config.chance_of_losing_guns_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_guns_anti")
    config.keep_guns_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_guns_chance")
    config.keep_guns_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_guns_chance_anti")
	config.chance_of_losing_gun_attachments = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_gun_attachments")
	config.chance_of_losing_gun_attachments_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_gun_attachments_anti")
    config.keep_gun_attachment_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_gun_attachment_chance")
    config.keep_gun_attachment_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_gun_attachment_chance_anti")
	config.chance_of_losing_outfits = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_outfits")
	config.chance_of_losing_outfits_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_outfits_anti")
    config.keep_outfit_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_outfit_chance")
    config.keep_outfit_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_outfit_chance_anti")
	config.chance_of_losing_artefacts = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_artefacts")
	config.chance_of_losing_artefacts_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_artefacts_anti")
	config.keep_artefact_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_artefact_chance")
	config.keep_artefact_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_artefact_chance_anti")
	config.chance_of_losing_devices = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_devices")
	config.chance_of_losing_devices_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_devices_anti")
	config.keep_device_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_device_chance")
	config.keep_device_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_device_chance_anti")
	config.chance_of_losing_kits = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_kits")
	config.chance_of_losing_kits_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_kits_anti")
	config.keep_kits_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_kits_chance")
	config.keep_kits_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_kits_chance_anti")
	config.chance_of_losing_tools = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_tools")
	config.chance_of_losing_tools_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_tools_anti")
	config.keep_tools_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_tools_chance")
	config.keep_tools_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_tools_chance_anti")
	config.chance_of_losing_explosives = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_explosives")
	config.chance_of_losing_explosives_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_explosives_anti")
    config.keep_explosives_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_explosives_chance")
    config.keep_explosives_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_explosives_chance_anti")
	config.chance_of_losing_ammo = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_ammo")
	config.chance_of_losing_ammo_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_ammo_anti")
    config.keep_ammo_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_ammo_chance")
    config.keep_ammo_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_ammo_chance_anti")
	config.chance_of_losing_medics = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_medics")
	config.chance_of_losing_medics_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_medics_anti")
	config.keep_medics_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_medics_chance")
	config.keep_medics_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_medics_chance_anti")
	config.chance_of_losing_items = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_items")
	config.chance_of_losing_items_anti = dwimg_mcm.get_config("item_loss/lose_keep/chance_of_losing_items_anti")
    config.keep_misc_items_chance = 100 - dwimg_mcm.get_config("item_loss/lose_keep/keep_misc_items_chance")
    config.keep_misc_items_chance_anti = dwimg_mcm.get_config("item_loss/lose_keep/keep_misc_items_chance_anti")
	--loss_scaling
	config.enable_scale = dwimg_mcm.get_config("item_loss/loss_scaling/enable_scale")
	config.scaling_exponent = dwimg_mcm.get_config("item_loss/loss_scaling/scaling_exponent")
	config.rank_scale_from = dwimg_mcm.get_config("item_loss/loss_scaling/rank_scale_from")
	config.rank_scale_until = dwimg_mcm.get_config("item_loss/loss_scaling/rank_scale_until")
	config.rank_loss_multiplier = dwimg_mcm.get_config("item_loss/loss_scaling/rank_loss_multiplier")
	config.rank_loss_multiplier_anti = dwimg_mcm.get_config("item_loss/loss_scaling/rank_loss_multiplier_anti")
	config.rank_loss_multiplier_anti_override = dwimg_mcm.get_config("item_loss/loss_scaling/rank_loss_multiplier_anti_override")
	config.rank_scale_from2 = dwimg_mcm.get_config("item_loss/loss_scaling/rank_scale_from2")
	config.rank_scale_until2 = dwimg_mcm.get_config("item_loss/loss_scaling/rank_scale_until2")
	config.rank_loss_multiplier2 = dwimg_mcm.get_config("item_loss/loss_scaling/rank_loss_multiplier2")
	config.rank_loss_multiplier_anti2 = dwimg_mcm.get_config("item_loss/loss_scaling/rank_loss_multiplier_anti2")
	config.rank_loss_multiplier_anti2_override = dwimg_mcm.get_config("item_loss/loss_scaling/rank_loss_multiplier_anti2_override")
	config.exemption_scale = dwimg_mcm.get_config("item_loss/loss_scaling/exemption_scale")

	if config.rank_scale_until <= config.rank_scale_from then
		config.rank_scale_until = config.rank_scale_from + 1
	end
	if config.rank_scale_until2 <= config.rank_scale_from2 then
		config.rank_scale_until2 = config.rank_scale_from2 + 1
	end		
end
local function load_settings_ignore()
	config.ignore_pda = dwimg_mcm.get_config("ignore/ignore_pda")
	config.ignore_backpack = dwimg_mcm.get_config("ignore/ignore_backpack")
	config.ignore_detector = dwimg_mcm.get_config("ignore/ignore_detector")
	config.ignore_torch_nvg = dwimg_mcm.get_config("ignore/ignore_torch_nvg")
	config.ignore_knife = dwimg_mcm.get_config("ignore/ignore_knife")
	config.ignore_axe = dwimg_mcm.get_config("ignore/ignore_axe")
	config.ignore_binoculars = dwimg_mcm.get_config("ignore/ignore_binoculars")
	config.ignore_special_equipment = dwimg_mcm.get_config("ignore/ignore_special_equipment")
end
local function load_settings_protection()
	config.max_rank_exemption = dwimg_mcm.get_config("protection/max_rank_exemption")
	config.gained_rank_exemption = dwimg_mcm.get_config("protection/gained_rank_exemption")
	config.max_time_exemption = dwimg_mcm.get_config("protection/max_time_exemption")
	config.passed_time_exemption = dwimg_mcm.get_config("protection/passed_time_exemption")
	config.max_rank_exemption2 = dwimg_mcm.get_config("protection/max_rank_exemption2")
	config.gained_rank_exemption2 = dwimg_mcm.get_config("protection/gained_rank_exemption2")
	config.max_time_exemption2 = dwimg_mcm.get_config("protection/max_time_exemption2")
	config.passed_time_exemption2 = dwimg_mcm.get_config("protection/passed_time_exemption2")
	config.exemption_everything = dwimg_mcm.get_config("protection/exemption_everything")	
	config.exemption_money = dwimg_mcm.get_config("protection/exemption_money")
	config.exemption_guns = dwimg_mcm.get_config("protection/exemption_guns")
	exemption_gun_attachements = dwimg_mcm.get_config("protection/exemption_gun_attachements")
	config.exemption_outfits = dwimg_mcm.get_config("protection/exemption_outfits")
	exemption_artefacts = dwimg_mcm.get_config("protection/exemption_artefacts")
	exemption_device = dwimg_mcm.get_config("protection/exemption_device")
	exemption_kit = dwimg_mcm.get_config("protection/exemption_kit")
	exemption_tools = dwimg_mcm.get_config("protection/exemption_tools")
	exemption_explosives = dwimg_mcm.get_config("protection/exemption_explosives")
	config.exemption_ammo = dwimg_mcm.get_config("protection/exemption_ammo")
	config.exemption_medics = dwimg_mcm.get_config("protection/exemption_medics")
	config.exemption_misc = dwimg_mcm.get_config("protection/exemption_misc")
end
local function load_settings_item_punish()
	--item_break
	config.broken_gun_chance = dwimg_mcm.get_config("item_punish/item_break/broken_gun_chance")
	config.broken_armor_chance = dwimg_mcm.get_config("item_punish/item_break/broken_armor_chance")
	config.keep_gun_armor_parts_chance = dwimg_mcm.get_config("item_punish/item_break/keep_gun_armor_parts_chance")
	config.keep_upgrade_chance = dwimg_mcm.get_config("item_punish/item_break/keep_upgrade_chance")
	config.broken_device_chance = dwimg_mcm.get_config("item_punish/item_break/broken_device_chance")
	config.keep_device_part_chance = dwimg_mcm.get_config("item_punish/item_break/keep_device_part_chance")
	--break_o
	config.remove_upgrade_chance = dwimg_mcm.get_config("item_punish/break_o/remove_upgrade_chance")
	config.downgrade_chance = dwimg_mcm.get_config("item_punish/break_o/downgrade_chance")
end
local function load_settings_character()
	config.quest_fail_chance = dwimg_mcm.get_config("character/quest_fail_chance")
	config.rank_loss = dwimg_mcm.get_config("character/rank_loss")
	config.goodwill_loss_flat = dwimg_mcm.get_config("character/goodwill_loss_flat")
	config.goodwill_loss_percent = dwimg_mcm.get_config("character/goodwill_loss_percent")
	config.min_goodwill = dwimg_mcm.get_config("character/min_goodwill")
	config.goodwill_friends = dwimg_mcm.get_config("character/goodwill_friends")
	config.goodwill_loss_flat_f = dwimg_mcm.get_config("character/goodwill_loss_flat_f") 		
	config.goodwill_loss_percent_f = dwimg_mcm.get_config("character/goodwill_loss_percent_f")	
	config.min_goodwill_f = dwimg_mcm.get_config("character/min_goodwill_f")
	config.goodwill_neutrals = dwimg_mcm.get_config("character/goodwill_neutrals")
	config.goodwill_loss_flat_n = dwimg_mcm.get_config("character/goodwill_loss_flat_n") 		
	config.goodwill_loss_percent_n = dwimg_mcm.get_config("character/goodwill_loss_percent_n")	
	config.min_goodwill_n = dwimg_mcm.get_config("character/min_goodwill_n")
	config.goodwill_enemies = dwimg_mcm.get_config("character/goodwill_enemies")
	config.goodwill_loss_flat_e = dwimg_mcm.get_config("character/goodwill_loss_flat_e") 		
	config.goodwill_loss_percent_e = dwimg_mcm.get_config("character/goodwill_loss_percent_e")	
	config.min_goodwill_e = dwimg_mcm.get_config("character/min_goodwill_e")
end
local function load_settings_day_time()
	--time_skip
    config.min_time_skip = dwimg_mcm.get_config("day_time/time_skip/min_time_skip")
    config.max_time_skip = dwimg_mcm.get_config("day_time/time_skip/max_time_skip")
    config.enable_wake_hours = dwimg_mcm.get_config("day_time/time_skip/enable_wake_hours")
    config.min_wake_hour = dwimg_mcm.get_config("day_time/time_skip/min_wake_hour")
    config.max_wake_hour = dwimg_mcm.get_config("day_time/time_skip/max_wake_hour")
	--sat_thirst
    config.satiety_loss_per_hour = dwimg_mcm.get_config("day_time/sat_thirst/satiety_loss_per_hour")
	config.min_satiety = dwimg_mcm.get_config("day_time/sat_thirst/min_satiety")
	config.min_thirst = dwimg_mcm.get_config("day_time/sat_thirst/min_thirst")
	
	if config.max_time_skip < config.min_time_skip then
		config.max_time_skip = config.min_time_skip
	end
	if config.min_time_skip + config.min_time_skip > 0 then
		config.enable_time_forward = true
	else
		config.enable_time_forward = false
	end
end
local function load_settings_old_stuff()
    config.min_health = dwimg_mcm.get_config("old_stuff/min_health")
    config.max_health = dwimg_mcm.get_config("old_stuff/max_health")
    config.full_heal_chance = dwimg_mcm.get_config("old_stuff/full_heal_chance")
    config.full_satiety_chance = dwimg_mcm.get_config("old_stuff/full_satiety_chance")
    config.remove_previous_stash = dwimg_mcm.get_config("old_stuff/remove_previous_stash")
    config.use_campfire_respawn = dwimg_mcm.get_config("old_stuff/use_campfire_respawn")
    config.use_stash_respawn = dwimg_mcm.get_config("old_stuff/use_stash_respawn")
    config.use_sleep_respawn = dwimg_mcm.get_config("old_stuff/use_sleep_respawn")

	if config.max_health < config.min_health then
		config.max_health = config.min_health
	end
end

function init_preset_filter()
	local filter_list = {}
	local to_filter = {"money", "condition", "item_loss", "ignore", "protection", "item_punish", "character", "day_time", "old_stuff"}
	for i=1, #to_filter do
		if dwimg_mcm.get_config("presets/custom_presets/cst_preset_" .. to_filter[i]) == true then
			filter_list[to_filter[i]] = true
			dwimg_utils.print_dbg("Added to filter list " .. to_filter[i])
		end	
		i = i+1
	end
	return filter_list
end

function check_presets()
	dwimg_mcm.preset_backup()
	
	--custom presets load
	if dwimg_mcm.get_config("presets/custom_presets/load_preset") then  
		dwimg_mcm.handle_preset(dwimg_mcm.get_config("presets/custom_presets/chosen_preset"), 'l', dwimg_mcm.on_mcm_load()["gr"], "", init_preset_filter(), false)
	end	
	
	--default presets
	local def_presets = {"money", "condition", "item_loss_basic", "item_loss_core", "item_loss_scaling", "item_punish", "ignore", "protection", "character"}
	for i=1, #def_presets do
		curr_preset_val =  dwimg_mcm.get_config("presets/default_presets/def_preset_" .. def_presets[i])
		if curr_preset_val ~= "n" then
			dwimg_mcm.load_def_preset(curr_preset_val)
		end
		i = i+1
	end
	
	--custom presetssave
	if dwimg_mcm.get_config("presets/custom_presets/save_preset") then
		dwimg_mcm.handle_preset(dwimg_mcm.get_config("presets/custom_presets/chosen_preset"), 's', dwimg_mcm.on_mcm_load()["gr"], "", init_preset_filter(), false)
	end
	dwimg_mcm.set_config("presets/custom_presets/save_preset", false)
	dwimg_mcm.set_config("presets/custom_presets/load_preset", false)
end

function load_settings()
	check_presets()

	if dwimg_mcm.get_config("debug/print_preset") then
		dwimg_utils.print_dbg("Start of preset copy paste")
	end
	load_settings_money()
	load_settings_condition()
	load_settings_item_loss()
	load_settings_ignore()
	load_settings_protection()
	load_settings_item_punish()
	load_settings_character()
	load_settings_day_time()
	load_settings_old_stuff()
	if dwimg_mcm.get_config("debug/print_preset") then
		dwimg_utils.print_dbg("End of preset copy paste")
	end

    config.display_issue = dwimg_mcm.get_config("debug/display_issue")
    config.use_dwimglog = dwimg_mcm.get_config("debug/use_dwimglog")

	init_protections()

end

function on_game_start()
    RegisterScriptCallback("on_option_change", load_settings)
    RegisterScriptCallback("on_game_load", load_settings)
    local ini_stash = ini_file("items\\settings\\backpack_stash.ltx")
    keep_items = utils_data.collect_section(ini_stash, "actor_backpack_keep_items", true)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_sleep", actor_on_sleep)
    RegisterScriptCallback("actor_on_stash_create", actor_on_stash_create)
    RegisterScriptCallback("actor_on_stash_remove", actor_on_stash_remove)
    RegisterScriptCallback("on_game_load", on_game_load)
    --RegisterScriptCallback("actor_on_before_hit", actor_on_before_hit)
    RegisterScriptCallback("on_before_save_input", on_before_save_input)
    --RegisterScriptCallback("on_key_press", on_key_press)
	RegisterScriptCallback("actor_on_item_take", actor_on_item_take)
	RegisterScriptCallback("actor_on_first_update",actor_on_first_update)
    options_vol = ui_options.get("sound/general/master_volume")
	dwimg_utils.print_dbg("V-3-1-p10")
end

function on_game_load()
	UnregisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    exec_console_cmd("snd_volume_eff " .. options_vol)
    -- Make sure older versions are updated:
    local sleep = dwimg_utils.get_sleep_state()
	if not sleep.last_dropped_item_list then
        sleep.last_dropped_item_list = {}
        sleep.last_lost_item_list = {}
    end
	death_init = false
end

local function handle_stashes()
    local sleep = dwimg_utils.get_sleep_state()
	if config.remove_previous_stash == 0 then
		return
	end
	while true do
		local list_length = 0
		local oldest_stash_id = nil
		local oldest_stash_time = nil
		for stash_id, _ in pairs(sleep.dropped_stashes) do
			dwimg_utils.print_dbg("Loop: " .. tostring(stash_id) .. " with time " .. tostring(sleep.dropped_stashes[stash_id]["time"]))
			list_length = list_length + 1
			if oldest_stash_time == nil or oldest_stash_time > sleep.dropped_stashes[stash_id]["time"] then
				oldest_stash_time = sleep.dropped_stashes[stash_id]["time"]
				oldest_stash_id = stash_id
				dwimg_utils.print_dbg("New oldest stash: " .. tostring(oldest_stash_id))
			end
		end
		if list_length <= config.remove_previous_stash then
			dwimg_utils.print_dbg("Not enough stashes: " .. tostring(list_length) .. " / " .. tostring(config.remove_previous_stash))
			return
		end
		if oldest_stash_id == nil then
			dwimg_utils.print_dbg("oldest stash is nil")
			return			
		end
		dwimg_utils.print_dbg("Too many stashes: " .. tostring(list_length) .. " / " .. tostring(config.remove_previous_stash))
		dwimg_utils.print_dbg("Delete oldest stash(id): " .. tostring(oldest_stash_id) .. " of " .. tostring(list_length) .. " in total.")
		sleep.dropped_stashes[oldest_stash_id] = nil
		level.map_remove_object_spot(oldest_stash_id, "treasure")
		alife_release_id(oldest_stash_id)
	end
end

function actor_on_first_update()
    local sleep = dwimg_utils.get_sleep_state()
	if sleep.dead then
        sleep.dead = false
		if db.actor.bleeding > 0 then
			dwimg_utils.print_dbg("Leftover bleeding " .. db.actor.bleeding)
		elseif sleep.bleed > 0 then
			dwimg_utils.print_dbg("Denied bleeding " .. sleep.bleed)
		else
			dwimg_utils.print_dbg("Never bleeded " .. db.actor.bleeding)
		end
		dwimg_utils.print_dbg("No longer an undead first update")
		db.actor.bleeding = 1
		db.actor.health = sleep.healing
		db.actor.psy_health = 1
		db.actor.power = 1
		bind_stalker_ext.invulnerable_time = time_global() - 1
		
		if sleep.health_status_msg and sleep.wounds_status_msg then
			db.actor:give_game_news("Recovery", sleep.wounds_status_msg .. sleep.health_status_msg, "ui_inGame2_neutral_2_mask", 0, 20000)
		end
		
		if not ((db.actor:character_rank() - sleep.rank < config.gained_rank_exemption) or (config.passed_time_exemption > (dwimg_utils.get_game_seconds() - sleep.time)/3600)) then
			dwimg_utils.print_dbg("New grace period")
			sleep.rank = db.actor:character_rank()
			sleep.time = dwimg_utils.get_game_seconds()
		end
		
		handle_stashes()
        -- db.actor:give_game_news("Severe Injured", sleep.health_status_msg, "ui_inGame2_neutral_2_mask", 5000, 20000)			

		--get_console():execute("hud_draw on")
	end
end

function actor_on_before_death(who, flags)

	do_item_dropping = true -- Drop items by default
	if has_alife_info("bar_arena_fight") or has_alife_info("bar_arena_start") then
		return
	elseif dwimg_utils.check_all_lists("ignored_levels", level.name()) then
		do_item_dropping = false -- Don't drop items in labs
	end

	dwimg_utils.print_dbg("Is undead")
    local sleep = dwimg_utils.get_sleep_state()
	sleep.dead = true
	bind_stalker_ext.invulnerable_time = time_global() + 10000
    local current_time = time_global()
    if last_death_time < current_time then
        last_death_time = current_time + 10000
        respawn_done = false
        sleep.last_death_time = last_death_time
    end
    if last_death_time > current_time and not respawn_done then
        respawn_done = true
        db.actor:set_health_ex(1)
        if not currently_respawning then
            dwimg_utils.print_dbg("currently_respawning if NOT %s", currently_respawning)
			apply_punishments()
            currently_respawning = 1
        end

        if currently_respawning == 1 then
            dwimg_utils.print_dbg("currently_respawning if 1 %s", currently_respawning)
            options_vol = ui_options.get("sound/general/master_volume")
			
            --get_console():execute("hud_draw off")
			
			level.disable_input()
            -- Temp remove to avoid crashes for non GAMMA players
            -- level.add_pp_effector("concussion_bhs.ppe", 99123, false)
            exec_console_cmd("snd_volume_eff " .. 0.01)
			time_item_calc = time_global()
            level.add_cam_effector("camera_effects\\surge_02.anm", 444, false, "dwimg_main.on_tutor_gameover_respawn")
            level.add_pp_effector("actor_death.ppe", 445, false)
            level.add_pp_effector("rcom_actor_death_quick.ppe", 446, false)

            currently_respawning = 2
        end
        
		local satiety
		local thirst
		local healing
		
        if currently_respawning == 2 then
        local forwardTimeMinHours = config.min_time_skip
        local forwardTimeMaxHours = config.max_time_skip
        local p = {}
        p[1] = math.floor(math.random(forwardTimeMinHours, forwardTimeMaxHours))
        if p[1] < forwardTimeMaxHours then
			p[2] = math.random(0, 59)
		else
			p[2] = 0
		end
		
		if config.enable_time_forward or config.enable_wake_hours then
			local cur_hour = level.get_time_hours()
			local final_day_hour = (((cur_hour + p[1]) / 24) % 1) * 24
			while final_day_hour < config.min_wake_hour or final_day_hour > config.max_wake_hour do
				final_day_hour = (((cur_hour + p[1]) / 24) % 1) * 24
				p[1] = p[1] + 1
			end
		end
		
        -- Heal, satiety, thirst calculation
        healing = math.random(config.min_health, config.max_health) / 100
        if math.random(1, 100) <= config.full_heal_chance then
            healing = 1
        end	
        satiety = db.actor.satiety
        local satiety_minus_per_hour = config.satiety_loss_per_hour / 100
		local thirst_minus_per_hor = config.satiety_loss_per_hour * 10
		thirst = 1 - actor_status_thirst.get_water_deprivation()
		if math.random(1, 100) <= config.full_satiety_chance then
			satiety = 1
			thirst = 1
        else
            -- Logic: db.actor can get a meal every 6 hours
            if satiety_minus_per_hour * p[1] >= satiety then
				satiety = config.min_satiety/100
            else
				satiety = satiety - (satiety_minus_per_hour * p[1])
				if (config.min_satiety/100) > satiety then
					satiety = config.min_satiety/100
				end
			end
            if satiety_minus_per_hour * p[1] * 0.5 >= thirst then
				thirst = config.min_thirst/100
            else
				thirst = thirst - (satiety_minus_per_hour * p[1] * 0.5)
				if (config.min_thirst/100) > thirst then
					thirst = config.min_thirst/100
				end
			end
        end
			
		dwimg_utils.print_dbg("currently_respawning if 2 %s", currently_respawning)
        sleep.health_status_msg = "You have been out of action for a while"
        if config.enable_time_forward or config.enable_wake_hours then
            --xr_effects.forward_game_time(nil, nil, p)
			level.change_game_time(0,p[1],p[2])
			skipped_time = p[1]*3600 + p[2]*60			
            sleep.health_status_msg = tostring(" You have been out of action for " .. p[1] .. " Hours and " .. p[2] .. " Minutes")		
            end
            currently_respawning = 3
        end

        if currently_respawning == 3 then
            bind_stalker_ext.respawn_new_health = healing
            global_healing = healing
            global_satiety = satiety
			global_thirst = thirst
            sleep.wounds_status_msg = tostring("You're finally awake and now feel slightly better: " ..
                                                   math.floor(global_healing * 100 + 0.5) .. "% of health " ..
                                                   math.floor(global_satiety * 100 + 0.5) .. "% Satiety" ..
												   math.floor(global_thirst * 100 + 0.5) .. "% thirst")
			currently_respawning = 4		
		end

        if currently_respawning == 4 then
			currently_respawning = nil
        end
		

        -- get_console():execute("hud_draw on")
        -- level.enable_input()
    end
    db.actor.health = global_healing
    -- db.actor:set_health_ex(global_healing)

    arszi_psy.set_psy_health(1)
    flags.ret_value = false
end

local no_sec_dwg = {}
local no_sec = {}

local function lose_rank_goodwill()

	db.actor:set_character_rank(db.actor:character_rank() * (1-(config.rank_loss/100)))
	
	local faction = {"stalker", "dolg", "freedom", "csky", "ecolog", "killer", "army", "bandit", "monolith", "greh", "renegade", "isg"}
	local actor_faction = db.actor:character_community()
	local faction_loss_flat
	local faction_loss_perc
	local faction_minimum
	for i, current_faction in ipairs(faction) do
		
		faction_loss_flat = config.goodwill_loss_flat
		faction_loss_perc = config.goodwill_loss_percent
		faction_minimum = config.min_goodwill
		if actor_faction ~= current_faction then
			if game_relations.is_factions_neutrals(current_faction, actor_faction) and config.goodwill_neutrals then
				faction_loss_flat = config.goodwill_loss_flat_n
				faction_loss_perc = config.goodwill_loss_percent_n
				faction_minimum = config.min_goodwill_n
			elseif game_relations.is_factions_enemies(current_faction, actor_faction) and config.goodwill_enemies then
				faction_loss_flat = config.goodwill_loss_flat_e
				faction_loss_perc = config.goodwill_loss_percent_e
				faction_minimum = config.min_goodwill_e
			elseif game_relations.is_factions_friends(current_faction, actor_faction) and config.goodwill_friends then
				faction_loss_flat = config.goodwill_loss_flat_f
				faction_loss_perc = config.goodwill_loss_percent_f
				faction_minimum = config.min_goodwill_f
			end
		end
		
		faction_goodwill = relation_registry.community_goodwill(current_faction, AC_ID)
		if faction_goodwill > faction_minimum then
			faction_goodwill = faction_goodwill - faction_loss_flat
			if faction_goodwill > faction_minimum then
				faction_goodwill = math.ceil(faction_goodwill - (faction_goodwill - faction_minimum) * faction_loss_perc * 0.01)
			end
			if  faction_goodwill < faction_minimum then
				faction_goodwill = faction_minimum
			end
			relation_registry.set_community_goodwill(current_faction, AC_ID, faction_goodwill )
		end
	end

end

local function lose_money()
	if not(config.exemption_money and (config.max_rank_exemption2 > db.actor:character_rank())) then
		local denominations = {{
			name = "money_1000",
			value = 1000
		}, {
			name = "money_100",
			value = 100
		}, {
			name = "money_10",
			value = 10
		}, {
			name = "roubles",
			value = 1
		}}
		local current_money = db.actor:money()
		local money_to_lose = math.random(math.floor(current_money * config.min_money_percentage), math.floor(current_money * config.max_money_percentage))
		if money_to_lose > config.max_lost_money + db.actor:character_rank() * config.money_y_rank then
			money_to_lose = config.max_lost_money + db.actor:character_rank() * config.money_y_rank
		end
		if (current_money - money_to_lose) < config.min_money_to_keep_general then
			if (config.min_money_to_keep_general >= current_money) then
				money_to_lose = 0
			else
				money_to_lose = current_money - config.min_money_to_keep_general
			end
		end
		if (current_money - money_to_lose) < config.min_money_to_keep_inventory then
			if (config.min_money_to_keep_inventory >= current_money) then
				money_to_lose = 0
			else
				money_to_lose = current_money - config.min_money_to_keep_inventory
			end
		end
		local money_left = 0

			db.actor:give_money(-money_to_lose)
			current_money = db.actor:money()
			money_left = math.floor(math.random((db.actor:money() * config.min_money_to_drop_percentage),
				(db.actor:money() * config.max_money_to_drop_percentage)))
				
			if (current_money - money_left) < config.min_money_to_keep_inventory then
				if (config.min_money_to_keep_inventory >= current_money) then
					money_left = 0
				else
					money_left = current_money - config.min_money_to_keep_inventory
				end
			end
			db.actor:give_money(-money_left)

		for _, denom in ipairs(denominations) do
			local num_items_to_create = math.floor(money_left / denom.value)
			money_left = money_left % denom.value
			for i = 1, num_items_to_create do
				alife_create_item(denom.name, dropped_stash)
			end
		end
		dwimg_utils.print_dbg("Total money to lose: " .. money_to_lose)
	end
end

function get_chances(item, section, item_id)
	local iType = dwimg_utils.get_item_type(item, "drop&loss chance")
	
	if iType == dwimg_lists.item_type.GUN then
		dwimg_utils.print_dbg("IsWeapon")
		dwimg_utils.print_dbg("guns_chance")
		return {config.chance_of_losing_guns, config.keep_guns_chance, false, config.chance_of_losing_guns_anti, config.keep_guns_chance_anti }
		
	elseif iType == dwimg_lists.item_type.UPGRADED then
		dwimg_utils.print_dbg("IsInDevices")
		dwimg_utils.print_dbg("upgraded_chance")
		return {config.chance_of_losing_devices, config.keep_device_chance, false, config.chance_of_losing_devices_anti, config.keep_device_chance_anti }
		
	elseif iType == dwimg_lists.item_type.TOOL then
		dwimg_utils.print_dbg("IsInTool_list")
		dwimg_utils.print_dbg("tools_chance")
		return {config.chance_of_losing_devices, config.keep_device_chance, false, config.chance_of_losing_devices_anti, config.keep_device_chance_anti }
		
	elseif iType == dwimg_lists.item_type.KIT then
		dwimg_utils.print_dbg("IsInKits_list")
		dwimg_utils.print_dbg("kits_chance")
		return {config.chance_of_losing_kits, config.keep_kits_chance, false, config.chance_of_losing_kits_anti, config.keep_kits_chance_anti }
		
	elseif iType == dwimg_lists.item_type.MEDICAL then
		dwimg_utils.print_dbg("IsMedicalKind")
		dwimg_utils.print_dbg("medics_chance")
		return {config.chance_of_losing_medics, config.keep_medics_chance, false, config.chance_of_losing_medics_anti, config.keep_medics_chance_anti }	

	elseif iType == dwimg_lists.item_type.ARMOR then
		dwimg_utils.print_dbg("IsOutfit")
		dwimg_utils.print_dbg("outfits_chance")
		return {config.chance_of_losing_outfits, config.keep_outfit_chance, false, config.chance_of_losing_outfits_anti, config.keep_outfit_chance_anti }	
		
	elseif iType == dwimg_lists.item_type.ARTEFACT_PERK or iType == dwimg_lists.item_type.ARTEFACT_STAT or iType == dwimg_lists.item_type.PELT then
		dwimg_utils.print_dbg("IsArtefact not i_attach")
		dwimg_utils.print_dbg("artefact_chance")
		return {config.chance_of_losing_artefacts, config.keep_artefact_chance, false, config.chance_of_losing_artefacts_anti, config.keep_artefact_chance_anti }
		
	elseif iType == dwimg_lists.item_type.ATTACHEMENT_WPN then
		dwimg_utils.print_dbg("IsWpnAttachment")
		dwimg_utils.print_dbg("gun_attachment_chance")
		return {config.chance_of_losing_gun_attachments, config.keep_gun_attachment_chance, false, config.chance_of_losing_gun_attachments_anti, config.keep_gun_attachment_chance_anti }
		
	elseif iType == dwimg_lists.item_type.EXPLOSIVE then
		dwimg_utils.print_dbg("IsExplosivesKind")
		dwimg_utils.print_dbg("explosives_chance")
		return {config.chance_of_losing_explosives, config.keep_explosives_chance, false, config.chance_of_losing_explosives_anti, config.keep_explosives_chance_anti }
		
	elseif iType == dwimg_lists.item_type.AMMO then
		dwimg_utils.print_dbg("IsAmmo")
		dwimg_utils.print_dbg("ammo_chance")	
		if string.match(item:section(), "^mag_") then
			local is_carried_mag = magazine_binder and magazine_binder.is_carried_mag
			local toggle_carried_mag = magazine_binder and magazine_binder.toggle_carried_mag
			local is_magazine = magazine_binder and magazine_binder.is_magazine
			if is_magazine(section) and is_carried_mag(item_id) then
				toggle_carried_mag(item_id)
			end		
		end	
		return {config.chance_of_losing_ammo, config.keep_ammo_chance, false, config.chance_of_losing_ammo_anti, config.keep_ammo_chance_anti }
	else
		dwimg_utils.print_dbg("misc_chance")
		if section == "bolt" or section == "bolt_bullet" then
			return {config.chance_of_losing_items, 100, false, config.chance_of_losing_items_anti, config.keep_misc_items_chance_anti}	
		else
			return {config.chance_of_losing_items, config.keep_misc_items_chance, false, config.chance_of_losing_items_anti, config.keep_misc_items_chance_anti }
		end
	end
end

local function get_exemption(item, section)
	local sleep = dwimg_utils.get_sleep_state()	
	if not sleep.rank then
		sleep.rank = 0
		sleep.time = 0
	end
	local i_type =  dwimg_utils.get_item_type(item, "exemption")
	local rule_a = false
	local rule_b = false
	
	-- Separate conditions for rule_a
	local max_rank_exemption_a = config.max_rank_exemption > db.actor:character_rank()
	local gained_rank_enabled_a = config.gained_rank_exemption > 0
	local gained_rank_exemption_a = gained_rank_enabled_a and (db.actor:character_rank() - sleep.rank < config.gained_rank_exemption)
	local passed_time_exemption_a = config.passed_time_exemption > (dwimg_utils.get_game_seconds() - (sleep.time+skipped_time))/3600
	local max_time_exemption_a = config.max_time_exemption > (dwimg_utils.get_game_seconds()-skipped_time)/3600
	
	rule_a = max_rank_exemption_a or gained_rank_exemption_a or passed_time_exemption_a or max_time_exemption_a
	
	-- Separate conditions for rule_b
	local max_rank_exemption_b = config.max_rank_exemption2 > db.actor:character_rank()
	local gained_rank_enabled_b = config.gained_rank_exemption2 > 0
	local gained_rank_exemption_b = gained_rank_enabled_b and (db.actor:character_rank() - sleep.rank < config.gained_rank_exemption2)
	local passed_time_exemption_b = config.passed_time_exemption2 > (dwimg_utils.get_game_seconds()-(skipped_time+sleep.time))/3600
	local max_time_exemption_b = config.max_time_exemption2 > (dwimg_utils.get_game_seconds()-skipped_time)/3600
	
	rule_b = max_rank_exemption_b or gained_rank_exemption_b or passed_time_exemption_b or max_time_exemption_b
	
	-- Print true conditions if any exemption applies
	if rule_a or rule_b then
		local true_conditions = {}
		if max_rank_exemption_a then table.insert(true_conditions, "max_rank_exemption_a") end
		if gained_rank_exemption_a then table.insert(true_conditions, "gained_rank_exemption_a") end
		if passed_time_exemption_a then table.insert(true_conditions, "passed_time_exemption_a") end
		if max_time_exemption_a then table.insert(true_conditions, "max_time_exemption_a") end
		if max_rank_exemption_b then table.insert(true_conditions, "max_rank_exemption_b") end
		if gained_rank_exemption_b then table.insert(true_conditions, "gained_rank_exemption_b") end
		if passed_time_exemption_b then table.insert(true_conditions, "passed_time_exemption_b") end
		if max_time_exemption_b then table.insert(true_conditions, "max_time_exemption_b") end
		dwimg_utils.print_dbg("Exemption conditions met: " .. table.concat(true_conditions, ", "))
	end
	
	--dwimg_utils.print_dbg("Current time " .. tostring(dwimg_utils.get_game_seconds()/3600) .. " without skipped time " .. tostring(skipped_time/3600) .. " is " .. tostring((dwimg_utils.get_game_seconds()-skipped_time)/3600) )
	if (rule_a == false) and (rule_b == false) then
		return false
	end
	
	if (config.exemption_everything == 1 and rule_a) or (config.exemption_everything == 2 and rule_b) then
		return true
	end
	
	if (rule_a and rule_a_prot[i_type]) or (rule_b and rule_b_prot[i_type]) then
		return true
	else
		return false
	end

end

local function disassemble(section, spw_target)
	local ind = 1
	local ini = ini_file("items\\settings\\craft.ltx")
	local result, id, value = 0, 0, 0
	
	while ini:section_exist(tostring(ind)) and not(tostring(id) == section) do
		local n = ini:line_count(tostring(ind)) or 0 
		local i = 0
		while i <= n-1 and not(tostring(id) == section) do
			result, id, value = ini:r_line(tostring(ind) , i , "", "")
			id = string.sub(id,3)
			i = i + 1
		end
	ind = ind + 1
	end
	local t = str_explode(value,",")
	if dwimg_utils.check_all_lists("devices",t[3]) ~= nil then
		disassemble(t[3], spw_target)
	end
	for i = 5, #t - 1, 2 do
		for i2 = 1, t[i+1] do
			if( math.random(1,100) <= config.keep_device_part_chance ) then
				local spw_prt = alife_create_item(t[i], spw_target)
				no_sec[spw_prt.id] = true
			end
		end
	end

end

local function main_disassemble(item, drop, obj, item_id, section)
	if (IsWeapon(item) and not(ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) and math.random(1,100) <= config.broken_gun_chance) or ((IsOutfit(item) or IsHeadgear(item)) and math.random(1,100) <= config.broken_armor_chance) or (dwimg_utils.check_all_lists("devices",section) ~= nil and math.random(1,100) <= config.broken_device_chance)  then
		local spw_target = db.actor
		if drop then
			spw_target = obj
		end
		if IsWeapon(item) or IsOutfit(item) or IsHeadgear(item) then
			if IsWeapon(item) then
				item:unload_magazine(true)
			end

			local spw_prt
			local parts = item_parts.get_parts_con(item)
			if parts then
				for k,v in pairs(parts) do
					if math.random(1,100) <= config.keep_gun_armor_parts_chance and (k ~= section) then
						spw_prt = alife_create_item(k, spw_target)
						if spw_prt then
							no_sec[tostring(spw_prt.id)] = true
							CreateTimeEvent("Wait_for_spawn", spw_prt.id, 0, function(id, con)
								if level.object_by_id(id) then
									--dwimg_utils.print_dbg("Condition: " .. con)
									level.object_by_id(id):set_condition(con/100)
									return true
								else
									return false
								end
							end, spw_prt.id, parts[k])
						else
							dwimg_utils.issue("No spw_prt spawned for "  .. section)
						end
					end
				end
			else
				dwimg_utils.issue("Couldn't find parts of item during main disassemble")
			end
			
			local installed_upgrades = utils_item.get_upgrades_installed(item)
			local upgr_tools = {}
			for i=1,#installed_upgrades do
				local tool = utils_item.get_upgrade_sect_tool(section, installed_upgrades[i])
				table.insert(upgr_tools,tool)
			end
			for i=1,#upgr_tools do
				if math.random(1,100) <= config.keep_upgrade_chance then
					spw_prt = alife_create_item(upgr_tools[i], spw_target)
					no_sec[tostring(spw_prt.id)] = true
				end
			end							
		else
			disassemble(section, spw_target)
		end
		return true
	else
		return false
	end
end

function scaled_chances(chances, item, section)
	if chances[3] == true or config.enable_scale == false then
		dwimg_utils.print_dbg("Case 1")
		return chances
	else
		local actor_rank = db.actor:character_rank()
		if ((IsWeapon(item) and not (IsGrenade(item) or IsMelee(item))) or IsOutfit(item) or IsHeadgear(item) or (IsArtefact(item) and not (ini_sys:r_string_ex(item:section(), "kind") == "i_attach")) or dwimg_utils.check_all_lists("devices",section) ~= nil ) and config.exemption_scale then
			--dwimg_utils.print_dbg("Case 2")
			return chances
		end

		--[[
					( effective_rank - config.rank_scale_from       ) ^config.scaling_exponent
			mult  = ( -------------------------------------- )					
					( config.rank_scale_until - config.rank_scale_from     )
		]]
		local effective_rank = dwimg_utils.clamp(actor_rank, config.rank_scale_from, config.rank_scale_until)
		local rank_mult = math.pow((effective_rank - config.rank_scale_from) / (config.rank_scale_until - config.rank_scale_from), config.scaling_exponent)
		dwimg_utils.print_dbg("Loss: Pow^" .. config.scaling_exponent .. ": actor_rank: " .. actor_rank .. " from: " .. config.rank_scale_from .. " until: " .. config.rank_scale_until .. " = " .. rank_mult)

		-- category override
		local multiplier_anti
		if config.rank_loss_multiplier_anti_override then
			dwimg_utils.print_dbg("Loss multiplier override: " .. chances[4])
			multiplier_anti = chances[4] 
		else
			dwimg_utils.print_dbg("Loss multiplier override: disabled")
			multiplier_anti = config.rank_loss_multiplier_anti
		end

		chances[1] = chances[1] * (1 + ((config.rank_loss_multiplier/100) * rank_mult))
		chances[1] = chances[1] + (((100-chances[1]) * ((multiplier_anti/100)) * rank_mult))

		if not(section == "bolt" or section == "bolt_bullet") then 
			--dwimg_utils.print_dbg("Case 3*")
			effective_rank = dwimg_utils.clamp(actor_rank, config.rank_scale_from2, config.rank_scale_until2)
			rank_mult = math.pow((effective_rank - config.rank_scale_from2) / (config.rank_scale_until2 - config.rank_scale_from2), config.scaling_exponent)
			dwimg_utils.print_dbg("Drop: Pow^" .. config.scaling_exponent .. ": actor_rank: " .. actor_rank .. " from: " .. config.rank_scale_from2 .. " until: " .. config.rank_scale_until2 .. " = " .. rank_mult)

			-- category override
			local multiplier_anti2
			if config.rank_loss_multiplier_anti2_override then
				dwimg_utils.print_dbg("Drop multiplier override: " .. chances[5])
				multiplier_anti2 = chances[5]
			else
				dwimg_utils.print_dbg("Drop multiplier override: disabled")
				multiplier_anti2 = config.rank_loss_multiplier_anti2
			end
			chances[2] = chances[2] - ((100-chances[2]) * ((config.rank_loss_multiplier2/100)* rank_mult))
			chances[2] = chances[2] - (chances[2] * (((multiplier_anti2/100)) * rank_mult))
		end
		--dwimg_utils.print_dbg("Case 3")
		return chances
	end
end

local function itr_inv(temp, item)
	dwimg_utils.print_dbg("item: " .. item:section() .. " [" .. item:id() .. "]")
	dwimg_utils.print_dbg(ini_sys:r_string_ex(item:section(), "kind"))
	local section = item:section()
	local item_id = item:id()
	time_item_calc = time_global()
	--if ini_sys:r_float_ex(section,"cost") ~= nil and ini_sys:r_float_ex(section,"cost") ~= 0 then 
	--	dwimg_utils.print_dbg("Cost of " .. item_id .. " is " .. ini_sys:r_float_ex(section,"cost"))
	--end
	
	if ignore_items[section] then
		dwimg_utils.print_dbg("Stopped for ignore: " .. item_id)
	   return
	end
	
	if dwimg_utils.get_item_type(item, "Quest item stop itr_inv") == dwimg_lists.item_type.QUEST then
		dwimg_utils.print_dbg("Stopped for QuestKind: " .. item_id)
		return
	end
	
	if item_id == b_id then
		dwimg_utils.print_dbg("Stopped for b_id: " .. item_id)
		return
	end
	
	if keep_items[section] ~= nil and not(dwimg_utils.check_all_lists("anti_keepers",section)) then
		dwimg_utils.print_dbg("Stopped for keep_items: " .. item_id)
		return
	end
						
	if ini_sys:r_bool_ex(section, "quest_item", false) then
		dwimg_utils.print_dbg("Stopped for quest_item: " .. item_id)
		return
	end

	if no_sec[tostring(item_id)] then
		dwimg_utils.print_dbg("Stopped for no spawn hook: " .. item_id)
		return
	end
	
	if get_exemption(item, section) then
		dwimg_utils.print_dbg("Exemption: " .. item_id)						
		return
	end
	
	--condition_loss
	if (config.max_condition_lose > 0) then
		if IsWeapon(item) and not (ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) and (item_backpack.is_in_slot(item) or config.condition_unequipped) then
			local parts = item_parts.get_parts_con(item)
			if parts then
					local count = 0
					for k, v in pairs(parts) do
						count = count + 1
					end
					local sum = 0
					for k, v in pairs(parts) do
						local condition_reduction =
							(math.random(config.min_condition_lose, config.max_condition_lose))
						if (config.min_weapon_condition < parts[k]) then
							if config.spread_weapon_condition then
								if math.random(1,2) == 1 then
									parts[k] = math.floor(parts[k] - (condition_reduction / count))
								else
									parts[k] = math.ceil(parts[k] - (condition_reduction / count))
								end
							else
								parts[k] = parts[k] - condition_reduction
							end
							if (parts[k] < config.min_weapon_condition) then
								parts[k] = config.min_weapon_condition
							end
						end
						sum = sum + parts[k]
					end
					item_parts.set_parts_con(item_id, parts)
			end
		elseif (IsOutfit(item) or IsHeadgear(item)) and (item_backpack.is_in_slot(item) or config.condition_unequipped) then
				local condition = item:condition()
				-- if killed by elemental damage increase condition lose of equipped items
				local condition_reduction =
					(math.random(config.min_condition_lose, config.max_condition_lose)) / 100
				if ((config.min_armor_condition / 100) < condition ) then
					condition = condition - condition_reduction
					if ((config.min_armor_condition / 100) > condition) then
						condition = config.min_armor_condition / 100
					end
				end
				item:set_condition(condition)
			
		end
	end

	--part break
	if ((IsWeapon(item) and not (ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) or IsOutfit(item) or IsHeadgear(item)) and (item_backpack.is_in_slot(item) or config.condition_unequipped)) and config.part_break_chance > 0 then
		local sum, cnt = 0,0
		local parts = item_parts.get_parts_con(item)
		for k, v in pairs(parts) do
			if k ~= section then
				if config.part_break_chance >= math.random(1,100) then
					parts[k] = 1
				end
				sum = sum + parts[k]
				dwimg_utils.print_dbg("summed " .. parts[k] .. " - " .. tostring(k))
				cnt = cnt + 1
			end
		end
		if IsOutfit(item) or IsHeadgear(item) then
			item:set_condition(dwimg_utils.clamp(math.ceil(sum/cnt),1,100)/100)
		end
		parts[section] = sum/cnt
		item_parts.set_parts_con(item_id, parts)
		
	end

	--remove scope, silencer and gl
	if IsWeapon(item) and not(ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsMelee(item) or IsGrenade(item)) then					
		local scope = detach_scope_dwimg(item)
		if scope ~= nil then
			--CreateTimeEvent("Wait_for_scope", scope["spw_att"].id, 0, function(id1, id2)
			--  dwimg_utils.print_dbg("Wait for scope " .. id1 .. " and weapon " .. id2)
			--  if level.object_by_id(id1) and level.object_by_id(id2) then
			--	itr_inv(nil, level.object_by_id(id2))
			--	itr_inv(nil, level.object_by_id(id1))
			--	return true
			--  else
			--	return false
			--  end
			--end, scope["spw_att"].id, scope["spw_wpn"].id)
			
			dwimg_utils.print_dbg("Cancelled for scope: " .. item_id)
			return
		end
		detach_suppressor_dwimg(item)
		detach_gl_dwimg(item)
	end

	--remove psu and convert overflow power to exo batteries_exo
	if IsOutfit(item) and item_exo_device.is_exo(item) and item_exo_device.check_remove_psu(item) == "st_remove_psu" then
		local power_overflow = 0
		if item_exo_device.get_data(item_id).power > 100 then
			power_overflow = item_exo_device.get_data(item_id).power - 100
		end
		while power_overflow > 0 do 
			local new_bat = alife_create_item("batteries_exo", db.actor)
			no_sec[tostring(new_bat.id)] = true
			CreateTimeEvent("Wait_for_spawn", new_bat.id, 0, function(id, charge)
			dwimg_utils.print_dbg("Wait for " .. id)
			if level.object_by_id(id) then
				level.object_by_id(id):set_condition(charge/100)
				return true
			else
				return false
			end
			end, new_bat.id, dwimg_utils.clamp(power_overflow, 0, 100))
			power_overflow = power_overflow - dwimg_utils.clamp(power_overflow, 0, 100)
		end
		item_exo_device.remove_psu(item)
	end
	
	--remove upgrades
	if not(no_sec_dwg[tostring(item_id)]) and ((IsWeapon(item) and not(ini_sys:r_string_ex(section, "kind") == "w_explosive" or IsGrenade(item) or IsMelee(item)) or IsOutfit(item) or IsHeadgear(item) or section == "wpn_binoc_inv")) and config.remove_upgrade_chance > 0  then
		local found_upgrades = dwimg_utils.shuffle_table(utils_item.get_upgrades_installed(item, item_id, false))
		local to_keep = dwimg_utils.binomial_sample(#found_upgrades, 100-config.remove_upgrade_chance)
		if #found_upgrades > 0 and not(to_keep == #found_upgrades ) then 	
			local clo_itm = alife_create_item(section, db.actor)
			no_sec_dwg[tostring(clo_itm.id)] = true
			item_parts.set_parts_con(clo_itm.id, item_parts.get_parts_con(item))
			local ammo 
			if IsWeapon(item) then
				ammo = item:get_ammo_in_magazine()
				item:unload_magazine(false)
			end
			alife_release(item)
			dwimg_utils.print_dbg("Wait for " .. clo_itm.id)
			CreateTimeEvent("Wait_for_spawn", clo_itm.id, 0, function(id, to_keep, found_upgrades)
				if level.object_by_id(id) then
					if IsWeapon(level.object_by_id(id)) then	
						level.object_by_id(id):unload_magazine(false)
					end
					local skip_upgr = {}
					local i = 1
					while to_keep > 0 do
						while skip_upgr[i] do
							i = i + 1
						end
						local rnd_upgr = found_upgrades[i]
						if not rnd_upgr then
							return true
						end
						dwimg_utils.print_dbg("try upgrade: " .. rnd_upgr .. " for " .. id .. " with " .. to_keep .. " missing")
						if not utils_item.has_this_upgrade(level.object_by_id(id), section, rnd_upgr) then
							inventory_upgrades.force_upgrade = true
							level.object_by_id(id):install_upgrade(rnd_upgr)
							if utils_item.has_this_upgrade(level.object_by_id(id), section, rnd_upgr) then
								to_keep = to_keep - 1
								skip_upgr[i] = true
								i=0
							end
						end
						i = i+1
					end
					
					if IsWeapon(level.object_by_id(id)) then
						level.object_by_id(id):set_ammo_elapsed(ammo)
					end
					return true
				else
					return false
				end
			end, clo_itm.id, to_keep, found_upgrades)
			dwimg_utils.print_dbg("Cancelled for upgrades: " .. item_id)
			return
		end
	end
	
	--downgrade
	if not(no_sec_dwg[tostring(item_id)]) and dwimg_utils.check_all_lists("devices",section) ~= nil and math.random(1, 100) <= config.downgrade_chance then
		dwimg_utils.print_dbg("Downgrade: " .. section .. " to " .. dwimg_utils.check_all_lists("devices",section))
		alife_release(item)
		local spw_itm = alife_create_item(dwimg_utils.check_all_lists("devices",section), db.actor)
		no_sec_dwg[tostring(spw_itm.id)] = true
		--CreateTimeEvent("Wait_for_spawn", spw_itm.id, 0, function(id)
		--  dwimg_utils.print_dbg("Wait for " .. id)
		--  if level.object_by_id(id) then
		--	no_sec_dwg[tostring(id)] = true
		--	itr_inv(nil, level.object_by_id(id))
		--	return true
		--  else
		--	return false
		--  end
		--end, spw_itm.id)
		dwimg_utils.print_dbg("Cancelled: " .. item_id)
		return
	end

	--[[ Here is how to get money value of item if ever needed
		ini_sys:r_float_ex(section,"cost")
	]]

	--other condition loss
	if (config.max_condition_lose2 > 0) then
		if (IsMelee(item) and config.condition_melee) or (dwimg_utils.get_item_type(item, "condition loss 2") == dwimg_lists.item_type.ARTEFACT_PERK and config.condition_perk_artefact) or (dwimg_utils.get_item_type(item, "condition loss 2") == dwimg_lists.item_type.ARTEFACT_STAT and config.condition_stat_artefact) or (dwimg_utils.get_item_type(item, "condition loss 2") == dwimg_lists.item_type.PELT and config.condition_pelt) then
			item:set_condition(dwimg_utils.clamp(item:condition()-math.random(config.min_condition_lose2, config.max_condition_lose2)/100,0.01,1))
		end
	end

	local chances = scaled_chances(get_chances(item, section, item_id), item, section)
	
	local loss_roll = math.random(1, 100)
	local loss_chance = chances[1]
	local lose = loss_roll <= loss_chance

	local drop_roll = math.random(1, 100)
	local drop_chance = 100 - chances[2]
	local drop = drop_roll <= drop_chance

	dwimg_utils.print_dbg("    #Fate said for " .. item_id .. " | lose = " .. tostring(lose) ..  " (" .. loss_roll .. "/" .. loss_chance .. ") | drop = " ..  tostring(drop) .. " (" .. drop_roll .. "/" .. drop_chance .. ")")
	--disassemble
	if not(lose) then
		if main_disassemble(item, drop, r_obj, item_id, section) then
			alife_release(item)	
			dwimg_utils.print_dbg("Cancelled for disassemble " .. item_id)
			return
		end
	end

	--drop loss keep
	if lose then
		-- I've noticed that for some reason bolts cannot be alife_released properly,
		-- it always results in a stacktrace. This is a bandaid to prevent that.
		if not IsBolt(item) then
			alife_release(item)
			add_to_dropped_item_list(item, 'l', dropped_stash.id)
		else
			dwimg_utils.print_dbg("Ignoring bolt loss " .. item_id)
		end
	elseif drop and do_item_dropping then
		db.actor:transfer_item(item, r_obj)
		add_to_dropped_item_list(item, 'd', dropped_stash.id)
	else
		return
	end
			
end

function actor_on_item_take(obj)
	local sleep = dwimg_utils.get_sleep_state()
	if obj and sleep.dead then
		time_item_calc = time_global()
		dwimg_utils.print_dbg("item spawn hook: [" .. obj:id() .. "]")
		CreateTimeEvent("Wait_for_death_inits", 0, 0, function(obj)
			dwimg_utils.print_dbg("Wait for " .. obj:id())
			if death_init then
				itr_inv(nil, obj)
				return true
			else
				return false
			end
		end, obj)
	end
end

function fail_quests()  
    local tm = task_manager.get_task_manager()  
    local task_info = tm.task_info  
    local task_ini = task_manager.task_ini  
      
    for task_id, info in pairs(task_info) do  
        if db.actor:get_task(task_id, true) and math.random(1,100) <= config.quest_fail_chance and   
           info.status ~= "fail" and   
           info.status ~= "completed" then  
              
            local is_storyline = task_ini:r_bool_ex(task_id, "storyline", false)  
              
            if not is_storyline then  
                local stage_complete = task_ini:r_float_ex(task_id, "stage_complete") or 254  
                local is_at_completion_stage = (info.stage == stage_complete)  
                  
                local is_truly_finished = is_at_completion_stage and   
                                        info.status ~= "fail" and   
                                        info.status ~= "completed" and  
                                        info.stage ~= 255  
                  
                if not is_truly_finished then  
                    --    ,     
                    info.cancelled_by_actor = true  
                      
                    --         
                    tm:set_task_failed(task_id)  
                      
                    printf("Failed secondary task without penalty: %s", task_id)  
                else  
                    printf("Preserved task ready for reward: %s (stage %s/%s)", task_id, info.stage, stage_complete)  
                end  
            end  
        end  
    end  
end

function apply_punishments()
	dropped_stash = nil
	r_obj = nil
	dwimg_utils.print_dbg("Dropping stash")
    dropped_stash = alife_create("inv_backpack", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
    local sleep = dwimg_utils.get_sleep_state()
	
			if not sleep.dropped_stashes then
				sleep.dropped_stashes = {}
			end
			sleep.dropped_stashes[dropped_stash.id] = {
				last_dropped_item_list = {},
				last_lost_item_list = {},
				time = dwimg_utils.get_game_seconds()
			}

			lose_rank_goodwill()
			lose_money()
			fail_quests()

			ignore_items = dwimg_utils.init_ignore()
			no_sec_dwg = {}
			no_sec = {}	

			if (dropped_stash) then
				local txt = strformat(game.translate_string("st_itm_stash_of_character"), db.actor:character_name())
				level.map_add_object_spot_ser(dropped_stash.id, "treasure", txt)
				--actor_menu.set_msg(1, game.translate_string("st_stash_created"), 4)

				local m_data = alife_storage_manager.get_state()
				if not (m_data.player_created_stashes) then
					m_data.player_created_stashes = {}
				end

				m_data.player_created_stashes[dropped_stash.id] = itm_backpack
				
				local function transfer_items(id, dwg_sec_check)
					r_obj = level.object_by_id(id)
					if (r_obj) then
						dwimg_utils.print_dbg("Dropped stash %s", dropped_stash.id)
						death_init = true
						db.actor:iterate_inventory(itr_inv)
						send_items_report_news_msg(false, dropped_stash.id)
						dwimg_utils.print_dbg("Finished loss and drop")
						inventory_upgrades.force_upgrade = false
						return true
					end
					return false
				end
				CreateTimeEvent("RAX SleepSpawn", "actor_backpack", 0, transfer_items, dropped_stash.id, false)
			end
end

function save_position(stash_data)
    local sleep = dwimg_utils.get_sleep_state()
    pos = db.actor:position()
    dwimg_utils.print_dbg("SAVE POSITION %s| %s %s %s |", level.name(), pos.x, pos.y, pos.z)
    if stash_data then
        sleep.stash_save = {}
        sleep.stash_created = true
        sleep.stash_save.level = level.name()
        sleep.stash_save.posX = pos.x
        sleep.stash_save.posY = pos.y
        sleep.stash_save.posZ = pos.z
        sleep.stash_save.position = vector():set(sleep.stash_save.posX or 0, sleep.stash_save.posY or 0,
            sleep.stash_save.posZ or 0)
        sleep.stash_save.level_vert = db.actor:level_vertex_id()
        sleep.stash_save.game_vert = db.actor:game_vertex_id()
        sleep.stash_save.stash_id = stash_data.stash_id
        sleep.type = "stash"
        level.map_add_object_spot_ser(stash_data.stash_id, "ui_pda2_actor_sleep_location", "Respawn")
    else
        sleep.level = level.name()
        sleep.posX = pos.x
        sleep.posY = pos.y
        sleep.posZ = pos.z
        sleep.position = vector():set(sleep.posX or 0, sleep.posY or 0, sleep.posZ or 0)
        sleep.level_vert = db.actor:level_vertex_id()
        sleep.game_vert = db.actor:game_vertex_id()
        sleep.sleep_created = true
        sleep.type = "sleep"
    end
    local save_message = strformat("Respawn point set.", text)
    exec_console_cmd("main_menu off")
    actor_menu.set_msg(1, save_message, 4) 
end

function actor_on_sleep()
    if not config.use_sleep_respawn or has_alife_info("bar_arena_fight") or has_alife_info("bar_arena_start") or dwimg_utils.check_all_lists("ignored_levels", level.name()) then
		return
	end
	local sleep = dwimg_utils.get_sleep_state()
	dwimg_utils.print_dbg("SET POSITION on SLEEP " .. tostring(config.use_sleep_respawn))
	sleep.sleep_created = true
	save_position()
end

function actor_on_stash_create(stash_data)
    if not(config.use_stash_respawn) or has_alife_info("bar_arena_fight") or has_alife_info("bar_arena_start") or dwimg_utils.check_all_lists("ignored_levels", level.name()) then
		return
	end
    local sleep = dwimg_utils.get_sleep_state()
    sleep.stash_created = true
    save_position(stash_data)
end

function actor_on_stash_remove(stash_data)
    local sleep = dwimg_utils.get_sleep_state()
    if sleep.stash_save and (stash_data.stash_id == sleep.stash_save.stash_id) then
        sleep.stash_created = false;
        sleep.stash_save = nil
        sleep.type = "sleep"
    end
    if sleep.dropped_stashes and sleep.dropped_stashes[stash_data.stash_id] then
        send_items_report_news_msg(true, stash_data.stash_id)
        sleep.dropped_stashes[stash_data.stash_id] = nil
    end
end

function on_before_save_input(flags, typ_, text)
	if not config.use_campfire_respawn or has_alife_info("bar_arena_fight") or has_alife_info("bar_arena_start") or dwimg_utils.check_all_lists("ignored_levels", level.name()) then
		return
	end
    local sleep = dwimg_utils.get_sleep_state()
    local nearby_campfire = bind_campfire.get_nearby_campfire(10, true)
    if not nearby_campfire then
        return
    end
	dwimg_utils.print_dbg("SET POSITION on CAMPFIRE " .. tostring(config.use_campfire_respawn))
	sleep.sleep_created = true
	save_position()
end

local function delete_empty_stash()
	local sleep = dwimg_utils.get_sleep_state()
	currently_respawning = nil
	local empty_stash = true
	r_obj:iterate_inventory_box( function(owner,itm)
		empty_stash = false
	end)
	if empty_stash == true  then	
		sleep.dropped_stashes[r_obj.id] = nil
		level.map_remove_object_spot(r_obj.id, "treasure")
		alife_release(r_obj)
		dwimg_utils.print_dbg("Empty stash detected and deleted!")
	end
end

local function set_player_stats()
	local sleep = dwimg_utils.get_sleep_state()
	sleep.bleed = db.actor.bleeding
	sleep.healing = global_healing
	db.actor.bleeding = 1
	db.actor.radiation = 0
	db.actor.health = global_healing
	dwimg_utils.print_dbg("dudsat" .. global_satiety .. " - " .. global_thirst)
	db.actor.satiety = (global_satiety*0.9)+0.1
	actor_status_thirst.load_state({drink = {last_drink = 8000*(0.99-global_thirst), chk_drink = nil}})
	actor_status_thirst.actor_on_update()
end

local function respawn_teleport()
	local sleep = dwimg_utils.get_sleep_state()
	
	if sleep and (sleep.posX and sleep.level and (sleep.level ~= level.name())) or
		(sleep.stash_save and sleep.stash_save.posX and sleep.stash_save.level and
			(sleep.stash_save.level ~= level.name())) then
		dwimg_utils.print_dbg("SAME LEVEL TELEPORT")
		if sleep.stash_created and config.use_stash_respawn then
			ChangeLevel(vector():set(sleep.stash_save.posX, sleep.stash_save.posY, sleep.stash_save.posZ), sleep.stash_save.level_vert,
				sleep.stash_save.game_vert, VEC_ZERO, false)
		else
			ChangeLevel(vector():set(sleep.posX, sleep.posY, sleep.posZ), sleep.level_vert,
				sleep.game_vert, VEC_ZERO, false)
		end
	elseif sleep and (sleep.posX or sleep.stash_save and sleep.stash_save.posX) then
		local player_lvid = db.actor:level_vertex_id()
		local player_gvid = db.actor:game_vertex_id()
		dwimg_utils.print_dbg("DIFFERENT LEVEL TELEPORT")
		if sleep.stash_created and config.use_stash_respawn then
			xr_effects.change_level_now(vector():set(sleep.stash_save.posX,  sleep.stash_save.posY, sleep.stash_save.posZ), player_lvid,
				player_gvid, VEC_ZERO, false)
		else
			xr_effects.change_level_now(vector():set(sleep.posX, sleep.posY, sleep.posZ), player_lvid,
				player_gvid, VEC_ZERO, false)
		end
	elseif db.actor:character_community() == "actor_stalker" then -- if loner >>
		dwimg_utils.print_dbg("LONER TELEPORT")
		xr_effects.change_level_now(vector():set(-246.0744, -24.8076, -136.0753), 14372, 372, VEC_ZERO, true) -- sidorovich's bunker
	elseif db.actor:character_community() == "actor_army" then -- if military >>
		xr_effects.change_level_now(vector():set(-123.26, -28.4, -379.96), 133511, 450, VEC_ZERO, true) -- southern checkpoint
	elseif db.actor:character_community() == "actor_bandit" then -- if bandit >>
		xr_effects.change_level_now(vector():set(20.72, 7.85, -42.93), 189149, 1515, VEC_ZERO, true) -- northern fdb.actory
	elseif db.actor:character_community() == "actor_csky" then -- if clear sky >>
		xr_effects.change_level_now(vector():set(-140.56, 1.5, -317.99), 75660, 136, VEC_ZERO, true) -- hidden base
	elseif db.actor:character_community() == "actor_dolg" then -- if duty >>
		xr_effects.change_level_now(vector():set(229.09, -5.449, 128.31), 59298, 1704, VEC_ZERO, true) -- duty headquarter
	elseif db.actor:character_community() == "actor_ecolog" then -- if ecologist >>
		xr_effects.change_level_now(vector():set(28.96, -10.05, -280.12), 78646, 2281, VEC_ZERO, true) -- sakharovs bunker
	elseif db.actor:character_community() == "actor_freedom" then -- if freedom >>
		xr_effects.change_level_now(vector():set(-18.02, -2.46, -31.74), 274912, 2092, VEC_ZERO, true) -- military base
	elseif db.actor:character_community() == "actor_killer" then -- if mercenary >>
		xr_effects.change_level_now(vector():set(-56.6, 8.92, 37.57), 96425, 2367, VEC_ZERO, true) -- sports center
	elseif db.actor:character_community() == "actor_monolith" then -- if monolith >>
		xr_effects.change_level_now(vector():set(-3.59, -3.50, 189.80), 98087, 3069, VEC_ZERO, true) -- cultural center
	elseif db.actor:character_community() == "actor_monolith" then -- if sin >>
		xr_effects.change_level_now(vector():set(-152.36056518555, 2.2933793067932, -26.791021347046), 5570, 2772,
			VEC_ZERO, true) -- red forest old mine
	elseif db.actor:character_community() == "actor_renegade" then -- if renegade >>
		xr_effects.change_level_now(vector():set(-179.78, 4.13, 417.23), 52100, 80, VEC_ZERO, true) -- tuzla outpost
	else -- if unisg/ other >>
		xr_effects.change_level_now(vector():set(136.32, 28.9, 240.395), 348892, 4920, VEC_ZERO, true) -- hideout in outskirts
	end
end

function on_tutor_gameover_respawn()
	CreateTimeEvent("Wait_for_item_calc", time_item_calc, 0, function() 
		if time_item_calc + 1000 > time_global() then
			--dwimg_utils.print_dbg("Waiting for respawn " .. tostring(time_global()) .. " / " .. tostring(time_item_calc+1000))
			return false
		else
			dwimg_utils.print_dbg("Finished waiting for item calcs and time skip")
			delete_empty_stash()
			set_player_stats()
			respawn_teleport()
			return true
		end
	end)	
end
