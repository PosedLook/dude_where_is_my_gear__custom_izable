--[[
Dude where's my gear!? is inspired by EFT, where you lose all your gear when you die.
The idea is to put together a hideout with some extra weapons and gear,
still you'll have the opportunity of getting some of your gear back if you return (and survive) to the place where you died.
You'll lose a % of money and also equipped items will lose condition when you drop them.
--]] 

local do_item_dropping -- disable item dropping if in underground labs
local currently_respawning = nil
local last_death_time = 0
local respawn_done = false
local global_healing = 1
local global_satiety = 1
local global_thirst = -10000
local options_vol = 1

death_init = false
skipped_time = 0
time_item_calc = nil
dropped_stash = nil
r_obj = nil

config = {} -- Configuration table to avoid 200 local variable limit

-- ==============================================================
-- ITEM LOSS MESSAGE
-- ==============================================================

function add_to_dropped_item_list(item, status, stash_id)
    local sleep = dwimg_utils.get_sleep_state()
    local item_name = ui_item.get_sec_name(item:section()) or 'unknown'
    local drop_stash = sleep.dropped_stashes[stash_id]
    if status == "d" then
        dwimg_utils.print_dbg("Dropped item: " .. item_name)
        if drop_stash.last_dropped_item_list[item_name] == nil then
            drop_stash.last_dropped_item_list[item_name] = 1
        else
            drop_stash.last_dropped_item_list[item_name] = drop_stash.last_dropped_item_list[item_name] + 1
        end
    elseif status == "l" then
        dwimg_utils.print_dbg("Lost item: " .. item_name)
        if drop_stash.last_lost_item_list[item_name] == nil then
            drop_stash.last_lost_item_list[item_name] = 1
        else
            drop_stash.last_lost_item_list[item_name] = drop_stash.last_lost_item_list[item_name] + 1
        end
    end
end

local function create_report_msg_string(list_lost_only, stash_id)
    list_lost_only = list_lost_only or false
    local sleep = dwimg_utils.get_sleep_state()
    local stash_items = sleep.dropped_stashes[stash_id] or nil
    local msg = ""
    if not list_lost_only and stash_items then
        for item_name, count in pairs(stash_items.last_dropped_item_list) do
            msg = msg .. "- " .. item_name .. " x" .. count .. " \\n"
            -- dwimg_utils.print_dbg("Dropped item: " .. item_name .. " x" .. count)
        end
    end
    if stash_items then
        for item_name, count in pairs(stash_items.last_lost_item_list) do
            msg = msg .. "- " .. item_name .. " x" .. count .. " \\n"
            -- dwimg_utils.print_dbg("Lost item: " .. item_name .. " x" .. count)
        end
    end
    return msg
end

local function send_items_report_news_msg(list_lost, stash_id)
    local items_recount = create_report_msg_string(list_lost, stash_id)
    local msg = list_lost and "You lost or got stolen:" or
                    "You woke up and did a quick item recount, looks like this is missing:"
    db.actor:give_game_news("Item recount", tostring(msg .. " \\n" .. items_recount), "ui_inGame2_neutral_2_mask", 0,
        20000)
end

-- ==============================================================
-- CATCH DEATH
-- ==============================================================

function actor_on_before_death(who, flags)

	do_item_dropping = true -- Drop items by default
	if has_alife_info("bar_arena_fight") or has_alife_info("bar_arena_start") then
		return
	elseif dwimg_utils.check_all_lists("ignored_levels", level.name()) then
		do_item_dropping = false -- Don't drop items in labs
	end

	dwimg_utils.print_dbg("Is undead")
    local sleep = dwimg_utils.get_sleep_state()
	sleep.dead = true
	bind_stalker_ext.invulnerable_time = time_global() + 10000
    local current_time = time_global()
    if last_death_time < current_time then
        last_death_time = current_time + 10000
        respawn_done = false
        sleep.last_death_time = last_death_time
    end
    if last_death_time > current_time and not respawn_done then
        respawn_done = true
        db.actor:set_health_ex(1)
        if not currently_respawning then
            dwimg_utils.print_dbg("currently_respawning if NOT %s", currently_respawning)
			apply_punishments()
            currently_respawning = 1
        end

        if currently_respawning == 1 then
            dwimg_utils.print_dbg("currently_respawning if 1 %s", currently_respawning)
            options_vol = ui_options.get("sound/general/master_volume")
			
            --get_console():execute("hud_draw off")
			
			level.disable_input()
            -- Temp remove to avoid crashes for non GAMMA players
            -- level.add_pp_effector("concussion_bhs.ppe", 99123, false)
            exec_console_cmd("snd_volume_eff " .. 0.01)
			time_item_calc = time_global()
            level.add_cam_effector("camera_effects\\surge_02.anm", 444, false, "dwimg_main.on_tutor_gameover_respawn")
            level.add_pp_effector("actor_death.ppe", 445, false)
            level.add_pp_effector("rcom_actor_death_quick.ppe", 446, false)

            currently_respawning = 2
        end
        
		local satiety
		local thirst
		local healing
		
        if currently_respawning == 2 then
        local forwardTimeMinHours = config.min_time_skip
        local forwardTimeMaxHours = config.max_time_skip
        local p = {}
        p[1] = math.floor(math.random(forwardTimeMinHours, forwardTimeMaxHours))
        if p[1] < forwardTimeMaxHours then
			p[2] = math.random(0, 59)
		else
			p[2] = 0
		end
		
		if config.enable_time_forward or config.enable_wake_hours then
			local cur_hour = level.get_time_hours()
			local final_day_hour = (((cur_hour + p[1]) / 24) % 1) * 24
			while final_day_hour < config.min_wake_hour or final_day_hour > config.max_wake_hour do
				final_day_hour = (((cur_hour + p[1]) / 24) % 1) * 24
				p[1] = p[1] + 1
			end
		end
		
        -- Heal, satiety, thirst calculation
        healing = math.random(config.min_health, config.max_health) / 100
        if math.random(1, 100) <= config.full_heal_chance then
            healing = 1
        end	
        satiety = db.actor.satiety
        local satiety_minus_per_hour = config.satiety_loss_per_hour / 100
		local thirst_minus_per_hor = config.satiety_loss_per_hour * 10
		thirst = 1 - actor_status_thirst.get_water_deprivation()
		if math.random(1, 100) <= config.full_satiety_chance then
			satiety = 1
			thirst = 1
        else
            -- Logic: db.actor can get a meal every 6 hours
            if satiety_minus_per_hour * p[1] >= satiety then
				satiety = config.min_satiety/100
            else
				satiety = satiety - (satiety_minus_per_hour * p[1])
				if (config.min_satiety/100) > satiety then
					satiety = config.min_satiety/100
				end
			end
            if satiety_minus_per_hour * p[1] * 0.5 >= thirst then
				thirst = config.min_thirst/100
            else
				thirst = thirst - (satiety_minus_per_hour * p[1] * 0.5)
				if (config.min_thirst/100) > thirst then
					thirst = config.min_thirst/100
				end
			end
        end
			
		dwimg_utils.print_dbg("currently_respawning if 2 %s", currently_respawning)
        sleep.health_status_msg = "You have been out of action for a while"
        if config.enable_time_forward or config.enable_wake_hours then
            --xr_effects.forward_game_time(nil, nil, p)
			level.change_game_time(0,p[1],p[2])
			skipped_time = p[1]*3600 + p[2]*60			
            sleep.health_status_msg = tostring(" You have been out of action for " .. p[1] .. " Hours and " .. p[2] .. " Minutes")		
            end
            currently_respawning = 3
        end

        if currently_respawning == 3 then
            bind_stalker_ext.respawn_new_health = healing
            global_healing = healing
            global_satiety = satiety
			global_thirst = thirst
            sleep.wounds_status_msg = tostring("You're finally awake and now feel slightly better: " ..
                                                   math.floor(global_healing * 100 + 0.5) .. "% of health " ..
                                                   math.floor(global_satiety * 100 + 0.5) .. "% Satiety" ..
												   math.floor(global_thirst * 100 + 0.5) .. "% thirst")
			currently_respawning = 4		
		end

        if currently_respawning == 4 then
			currently_respawning = nil
        end
		

        -- get_console():execute("hud_draw on")
        -- level.enable_input()
    end
    db.actor.health = global_healing
    -- db.actor:set_health_ex(global_healing)

    arszi_psy.set_psy_health(1)
    flags.ret_value = false
end

-- ==============================================================
-- INIT AND CALL PUNISHMENT CALCULATIONS
-- ==============================================================

function apply_punishments()
	dropped_stash = nil
	r_obj = nil
	dwimg_utils.print_dbg("Dropping stash")
    dropped_stash = alife_create("inv_backpack", db.actor:position(), db.actor:level_vertex_id(), db.actor:game_vertex_id())
    local sleep = dwimg_utils.get_sleep_state()
	
	sleep.dropped_stashes[dropped_stash.id] = {
		last_dropped_item_list = {},
		last_lost_item_list = {},
		time = dwimg_utils.get_game_seconds()
	}

	dwimg_other_punish.lose_rank_goodwill()
	dwimg_other_punish.lose_money()
	dwimg_other_punish.fail_quests()

	dwimg_items.ignore_items = dwimg_utils.init_ignore()
	dwimg_items.no_sec_dwg = {}
	dwimg_items.no_sec = {}	

	if (dropped_stash) then
		local txt = strformat(game.translate_string("st_itm_stash_of_character"), db.actor:character_name())
		level.map_add_object_spot_ser(dropped_stash.id, "treasure", txt)
		--actor_menu.set_msg(1, game.translate_string("st_stash_created"), 4)

		local m_data = alife_storage_manager.get_state()
		if not (m_data.player_created_stashes) then
			m_data.player_created_stashes = {}
		end

		m_data.player_created_stashes[dropped_stash.id] = itm_backpack
		
		local function transfer_items(id, dwg_sec_check)
			r_obj = level.object_by_id(id)
			if (r_obj) then
				dwimg_utils.print_dbg("Dropped stash %s", dropped_stash.id)
				death_init = true
				db.actor:iterate_inventory(dwimg_items.itr_inv)
				send_items_report_news_msg(false, dropped_stash.id)
				inventory_upgrades.force_upgrade = false
				return true
			end
			return false
		end
		CreateTimeEvent("RAX SleepSpawn", "actor_backpack", 0, transfer_items, dropped_stash.id, false)
	else
		dwimg_utils.issue("Did not find dropped stash")
	end
end

-- ==============================================================
-- PREPARE AFTER DEATH RESPAWN
-- ==============================================================

local function delete_empty_stash()
	local sleep = dwimg_utils.get_sleep_state()
	currently_respawning = nil
	local empty_stash = true
	r_obj:iterate_inventory_box( function(owner,itm)
		empty_stash = false
	end)
	if empty_stash == true  then	
		sleep.dropped_stashes[r_obj.id] = nil
		level.map_remove_object_spot(r_obj.id, "treasure")
		alife_release(r_obj)
		dwimg_utils.print_dbg("Empty stash detected and deleted!")
	end
end

local function set_player_stats()
	local sleep = dwimg_utils.get_sleep_state()
	sleep.bleed = db.actor.bleeding
	sleep.healing = global_healing
	db.actor.bleeding = 1
	db.actor.radiation = 0
	db.actor.health = global_healing
	dwimg_utils.print_dbg("dudsat" .. global_satiety .. " - " .. global_thirst)
	db.actor.satiety = (global_satiety*0.9)+0.1
	actor_status_thirst.load_state({drink = {last_drink = 8000*(0.99-global_thirst), chk_drink = nil}})
	actor_status_thirst.actor_on_update()
end

function on_tutor_gameover_respawn()
	CreateTimeEvent("Wait_for_item_calc", time_item_calc, 0, function() 
		if time_item_calc + 1000 > time_global() then
			--dwimg_utils.print_dbg("Waiting for respawn " .. tostring(time_global()) .. " / " .. tostring(time_item_calc+1000))
			return false
		else
			dwimg_utils.print_dbg("Finished waiting for item calcs and time skip")
			death_init = false
			delete_empty_stash()
			set_player_stats()
			dwimg_respawn.respawn_teleport()
			return true
		end
	end)	
end

-- ==============================================================
-- INIT SCRIPT CALLBACKS
-- ==============================================================

function on_game_start()
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("on_game_load", on_game_load)
    options_vol = ui_options.get("sound/general/master_volume")
	dwimg_utils.print_dbg("V-3-1-p13-dev")
end

function on_game_load()
	UnregisterScriptCallback("actor_on_before_death", actor_on_before_death)
    RegisterScriptCallback("actor_on_before_death", actor_on_before_death)
    exec_console_cmd("snd_volume_eff " .. options_vol)
end