-- ==============================================================
-- MATH AND LOGICAL UTILS
-- ==============================================================

function clamp(x, min_val, max_val)
    return math.max(min_val, math.min(x, max_val))
end

function binomial_sample(y, x)
    local successes = 0
    for i = 1, y do
        if math.random(1,100) < x then
            successes = successes + 1
        end
    end
    return successes
end

function shuffle_table(tbl)
    for i = #tbl, 2, -1 do
        local j = math.random(i)
        tbl[i], tbl[j] = tbl[j], tbl[i]
    end
    return tbl
end

local function deep_copy_table(tbl)
    local copy = {}
    for k, v in pairs(tbl) do
        if type(v) == "table" then
            copy[k] = deep_copy_table(v)
        else
            copy[k] = v
        end
    end
    return copy
end

-- ==============================================================
-- GAME UTILS
-- ==============================================================

function get_game_seconds()
    return math.floor(game.get_game_time():diffSec(level.get_start_time()))
end

-- ==============================================================
-- DWIMG GENERAL UTILS
-- ==============================================================

function print_dbg(text, ...)
    if true then
        printf("DUD: | %s |  " .. text, time_global(), ...)
    end
end

function issue(dbg_msg)
	if dwimg_main.dwimg_main.config.display_issue then
		actor_menu.set_msg(1, strformat("Dude where is my gear ran into an issue! Please save the log for further investigation! (You can keep playing)", text), 10)
        print_dbg("dwimg_issue: " .. dbg_msg)
    end
end

function get_sleep_state()
	if not alife_storage_manager.get_state().dude_where_is_my_gear then
		alife_storage_manager.get_state().dude_where_is_my_gear = deep_copy_table(dwimg_lists.blank_sleep_state)
	end
	return alife_storage_manager.get_state().dude_where_is_my_gear
end

function on_game_start()
	local state = alife_storage_manager.get_state().dude_where_is_my_gear
	if not state then
		state = deep_copy_table(dwimg_lists.blank_sleep_state)
	else
		for i, v in pairs(dwimg_lists.blank_sleep_state) do
            if state[i] == nil then
				if type(v) == "table" then
					state[i] = deep_copy_table(v)
				else
					state[i] = v
				end
			end
		end
	end
end

-- ==============================================================
-- DWIMG SPECIFIC UTILS
-- ==============================================================

-- --------------------------------------------------------------
-- HANDLING ALL LISTS
-- --------------------------------------------------------------

function check_all_lists(list, i)
	return dwimg_lists.all_lists[list][i]
end

function init_ignore()
	local ignore_items = {}
	for i = 1, dwimg_main.config.ignore_pda do
		ignore_items[dwimg_utils.check_all_lists("list_ignore_pda",i)] = true
	end
	for i = 1, dwimg_main.config.ignore_backpack do
		ignore_items[dwimg_utils.check_all_lists("list_ignore_backpack",i)] = true
	end
	for i = 1, dwimg_main.config.ignore_detector do
		ignore_items[dwimg_utils.check_all_lists("list_ignore_detector",i)] = true
	end	
	for i = 1, dwimg_main.config.ignore_torch_nvg do
		ignore_items[dwimg_utils.check_all_lists("list_ignore_torch_nvg",i)] = true
	end	
	for i = 1, dwimg_main.config.ignore_knife do
		ignore_items[dwimg_utils.check_all_lists("list_ignore_knife",i)] = true
	end	
	if dwimg_main.config.ignore_axe then
		for i = 1, #dwimg_lists.all_lists["list_ignore_axe"] do
			ignore_items[dwimg_utils.check_all_lists("list_ignore_axe",i)] = true
		end
	end
	if dwimg_main.config.ignore_special_equipment then
		for i = 1, #dwimg_lists.all_lists["list_ignore_special_equipment"] do
			ignore_items[dwimg_utils.check_all_lists("list_ignore_special_equipment",i)] = true
		end
	end
	if dwimg_main.config.ignore_binoculars then
		ignore_items["wpn_binoc_inv"] = true
	end
	return ignore_items
end

-- --------------------------------------------------------------
-- HANDLING ITEM TYPES
-- --------------------------------------------------------------

function get_item_type(item, dbg_info)
	local r_type = dwimg_lists.item_type.MISC
	local g_type = (ini_sys:r_string_ex(item:section(), "kind"))
	
	if g_type == "i_medical" then
		r_type = dwimg_lists.item_type.MEDICAL
	elseif IsWeapon(item) and not (IsGrenade(item) or IsMelee(item)) then
		r_type = dwimg_lists.item_type.GUN
	elseif dwimg_utils.check_all_lists("devices",section) ~= nil then
		r_type = dwimg_lists.item_type.UPGRADED
	elseif dwimg_utils.check_all_lists("tools_list",section) then
		r_type = dwimg_lists.item_type.TOOL
	elseif dwimg_utils.check_all_lists("kits_list",section) then
		r_type = dwimg_lists.item_type.KIT
	elseif IsOutfit(item) or IsHeadgear(item) then
		r_type = dwimg_lists.item_type.ARMOR
	elseif g_type == "w_ammo" or string.match(item:section(), "^mag_") or IsAmmo(item) then
		r_type = dwimg_lists.item_type.AMMO
	elseif g_type == "w_explosive" then
		r_type = dwimg_lists.item_type.EXPLOSIVE
	elseif g_type == "i_arty_junk" then
		r_type = dwimg_lists.item_type.ARTEFACT_PERK
	elseif g_type == "i_arty" then
		r_type = dwimg_lists.item_type.ARTEFACT_STAT
	elseif g_type == "i_mutant_belt" then
		r_type = dwimg_lists.item_type.PELT
	elseif (ini_sys:r_string_ex(item:section(), "kind") == "w_misc") and not (item:section() == "bolt_bullet" or item:section() == "bolt" or item:section() == "wpn_binoc_inv") then
		r_type = dwimg_lists.item_type.ATTACHEMENT_WPN
	elseif g_type == "i_quest" then
		r_type = dwimg_lists.item_type.QUEST
	end
	
	dwimg_utils.print_dbg("Item type of <" .. tostring(item:section()) .. "> for <" .. dbg_info .. "> is <" .. r_type .. ">")
	return r_type
end

-- --------------------------------------------------------------
-- DETACH WEAPON ATTACHEMENTS
-- --------------------------------------------------------------

function detach_scope_dwimg(weapon)
	local detach_infos = {
	["spw_wpn"] = nil,
	["spw_att"] = nil,
	}
	local parent_section = ini_sys:r_string_ex(weapon:section(),"parent_section")
	if (not parent_section or weapon:section() == parent_section) then 
		return nil
	end
	
	local old_weapon = alife_object(weapon:id())	
	
	-- Determine which addon is attached to the weapon.
	-- Create the item in the db.actor's inventory when found.
	for k, v in pairs(utils_data.collect_sections(ini_sys, {"addons_table"})) do
		if (string.find(weapon:section(), k)) then
			--give_object_to_db.actor(k)
			detach_infos["spw_att"] = alife_create_item(k, db.actor)
			break
		end
	end
	if detach_infos["spw_att"] == nil then
		return nil
	end
	-- Create objects for the 'before' and 'after' detachment weapons.
	local new_weapon = old_weapon and alife_clone_weapon(old_weapon, parent_section)
	detach_infos["spw_wpn"] = new_weapon
	return detach_infos
end

function detach_suppressor_dwimg(weapon)	
	if weapon:weapon_silencer_status() == 2 then
		if weapon:weapon_is_silencer() then
			local supSection = utils_item.get_param(weapon:section(), weapon:id(), "silencer_name", "string")
			local sil_info = {id = weapon:id(), section = supSection}
			weapon:weapon_addon_detach(sil_info.section, true)
			--dwimg_utils.print_dbg("Detached suppressor")
			return true
		end
	end
	return false
end

function detach_gl_dwimg(weapon)
	if (ini_sys:r_float_ex(weapon:section(),"grenade_launcher_status") > 0) then
		if weapon:is_weapon_gl() then
			local supSection = utils_item.get_wpn_param(obj, weapon:section(), "grenade_launcher_name")
			local gl_info = {id = weapon:id(), section = supSection}
			weapon:weapon_addon_detach(gl_info.section, true)
			--dwimg_utils.print_dbg("Detached gl")
			return true		
		end
	end
	return false
end